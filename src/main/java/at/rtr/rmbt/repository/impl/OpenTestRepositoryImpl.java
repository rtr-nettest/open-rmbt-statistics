package at.rtr.rmbt.repository.impl;

import at.rtr.rmbt.constant.Constants;
import at.rtr.rmbt.dto.Classification;
import at.rtr.rmbt.dto.ImageGenerateDto;
import at.rtr.rmbt.dto.SpeedGraphItemDTO;
import at.rtr.rmbt.dto.SpeedItems;
import at.rtr.rmbt.repository.OpenTestRepository;
import at.rtr.rmbt.response.OpenTestDetailsDTO;
import at.rtr.rmbt.response.opentest.OpenTestDTO;
import at.rtr.rmbt.response.opentest.OpenTestSearchResponse;
import at.rtr.rmbt.utils.QueryParser;
import at.rtr.rmbt.utils.SqlUtils;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.stereotype.Service;

import java.sql.*;
import java.util.*;

@Service
@Slf4j
@RequiredArgsConstructor
public class OpenTestRepositoryImpl implements OpenTestRepository {

    private final JdbcTemplate jdbcTemplate;

    //maximum of rows sent in one single request
    public final int MAX_SEARCH_ROWS = 10000;  //maximum number of rows allowed, currently approx 1.5s response time at maximum

    public final int DEFAULT_SEARCH_ROWS = 100; //default number of rows (when max_results is not specified)


    @Override
    public OpenTestSearchResponse getOpenTestSearchResults(QueryParser qp, long offset, long maxrows, Set<String> additionalFields) {
        long startTime = System.currentTimeMillis();
        OpenTestSearchResponse.OpenTestSearchResponseBuilder dto = OpenTestSearchResponse.builder();

        String offsetString = (offset > 0) ? " AND t.uid<" + offset : ""; //if no sorting is used
        String offsetString2 = (offset > 0) ? " OFFSET " + offset : ""; //if sorting is used => may have concurrency issues in the results

        String orderClause = qp.getOrderClause();
        boolean defaultOrder = true;
        if (orderClause == null || orderClause.isEmpty()) {
            orderClause = " ORDER BY t.uid DESC ";
            offsetString2 = "";
        } else {
            defaultOrder = false;
            offsetString = "";
        }

        if (maxrows > MAX_SEARCH_ROWS)
            maxrows = MAX_SEARCH_ROWS;
        if (maxrows <= 0)
            maxrows = DEFAULT_SEARCH_ROWS;


        //There are many LEFT JOINs in the sql statement that are usual not needed.
        //This has no significant impact on the performance since our DBMS (postgres)
        //is intelligent enough to ignore these during query optimization if they are
        //not needed
        final String sql = "SELECT" +
                " t.uid as cursor, " + //only for pagination
                " ('P' || t.open_uuid) open_uuid," +
                " ('O' || t.open_test_uuid) open_test_uuid," +
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
                //" nt.group_name cat_technology," +
                //" nt.name network_type," +

                //csv 6:lat
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_lat" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_lat*1111)/1111" + // approx 100m
                " ELSE null" +
                " END) latitude," +
                // csv 7:long
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_long" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_long*741)/741 " + //approx 100m
                " ELSE null" +
                " END) longitude," +
                // accuracy of geo location in m
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') " +
                " THEN t.geo_accuracy " +
                " WHEN (t.geo_accuracy < 100) AND ((t.geo_provider = 'manual') OR (t.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
                " WHEN (t.geo_accuracy < ?) THEN t.geo_accuracy" +
                " ELSE null END) loc_accuracy, " +
                //" t.geo_provider loc_src," +
                " t.speed_download download_kbit," +
                " t.speed_upload upload_kbit," +
                " (t.ping_median::float / 1000000) ping_ms," +
                " t.signal_strength," +
                " t.lte_rsrp," +
                //" ts.name server_name," +
                //" duration test_duration," +
                //" num_threads," +
                " CONCAT(plattform,' ',network_group_name) as platform, " +
                " network_group_name cat_technology," +
                " COALESCE(adm.fullname, t.model) model," +
                " COALESCE(mprov.shortname, t.network_operator_name, prov.shortname, msim.shortname,msim.name,"
                + "    prov.name, mprov.name, t.public_ip_as_name, network_sim_operator) provider_name " +
                //" client_software_version client_version," +
                //" network_operator network_mcc_mnc," +
                //" network_operator_name network_name," +
                //" network_sim_operator sim_mcc_mnc," +
                //" nat_type \"connection\"," +
                //" public_ip_asn asn," +
                //" client_public_ip_anonymized ip_anonym," +
                //" (ndt.s2cspd*1000)::int ndt_download_kbit," +
                //" (ndt.c2sspd*1000)::int ndt_upload_kbit" +
                " FROM test t" +
                qp.getJoins() +
                " WHERE " +
                " (t.deleted = false)" +
                " AND status = 'FINISHED' " + qp.getWhereClause("AND") + offsetString +
                orderClause + " LIMIT " + maxrows + offsetString2;
        try {
            List<OpenTestDTO> results = jdbcTemplate.query(new PreparedStatementCreator() {
                @Override
                public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                    return con.prepareStatement(sql);
                }
            }, new PreparedStatementSetter() {
                @Override
                public void setValues(PreparedStatement ps) throws SQLException {
                    double accuracy = Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT;
                    ps.setDouble(1, accuracy);
                    ps.setDouble(2, accuracy);
                    ps.setDouble(3, accuracy);
                    ps.setDouble(4, accuracy);
                    ps.setDouble(5, accuracy);
                    ps.setDouble(6, accuracy);
                    qp.fillInWhereClause(ps, 7);
                }
            }, new ResultSetExtractor<List<OpenTestDTO>>() {
                @Override
                public List<OpenTestDTO> extractData(ResultSet rs) throws SQLException, DataAccessException {
                    List<OpenTestDTO> list = new ArrayList<OpenTestDTO>();
                    while (rs.next()) {
                        OpenTestDTO openTestDTO = OpenTestDTO.builder()
                                .cursor(rs.getLong("cursor"))
                                .openUuid(rs.getString("open_uuid"))
                                .openTestUuid(rs.getString("open_test_uuid"))
                                .latitude(SqlUtils.getDoubleOrNull(rs, "latitude"))
                                .longitude(SqlUtils.getDoubleOrNull(rs, "longitude"))
                                .locAccuracy(SqlUtils.getDoubleOrNull(rs, "loc_accuracy"))
                                .lteRsrp(SqlUtils.getIntegerOrNull(rs, "lte_rsrp"))
                                .model(rs.getString("model"))
                                .platform(rs.getString("platform"))
                                .providerName(rs.getString("provider_name"))
                                .signalStrength(SqlUtils.getIntegerOrNull(rs, "signal_strength"))
                                .time(rs.getString("time"))
                                .downloadKbit(SqlUtils.getIntegerOrNull(rs, "download_kbit"))
                                .uploadKbit(SqlUtils.getIntegerOrNull(rs, "upload_kbit"))
                                .pingMs(SqlUtils.getDoubleOrNull(rs, "ping_ms"))
                                .build();
                        list.add(openTestDTO);
                    }
                    return list;
                }
            });

            dto.results(results);

            //remember last uid for pagination since rs can only be traversed in one direction
            //if there are more results than we send, use pagination
            if (results.size() == maxrows) {
                //if it is the standard sort order
                if (defaultOrder) {
                    dto.nextCursor(results.get(results.size() - 1).getCursor());
                } else {
                    offset = (offset < 0) ? 0 : offset;
                    dto.nextCursor(offset + maxrows);
                }
            } else {
                dto.nextCursor(null);
            }

            //also put in the result, how long the query took to execute
            long elapsedTime = System.currentTimeMillis() - startTime;
            //jsonResponse.put("duration_ms",elapsedTime);
            dto.durationMs(elapsedTime);

            if (additionalFields != null) {
                for (OpenTestDTO result : results) {
                    if (additionalFields.contains("download_classification")) {
                        result.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, result.getDownloadKbit(), 4));
                    }
                    if (additionalFields.contains("upload_classification")) {
                        result.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, result.getUploadKbit(), 4));
                    }
                    if (additionalFields.contains("ping_classification")) {
                        result.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(result.getPingMs() * 1000000), 4));
                    }
                    if (additionalFields.contains("signal_classification") && (result.getSignalStrength() != null || result.getLteRsrp() != null)) {
                        if (result.getPlatform().contains("WLAN")) { // RSSI for Wifi
                            result.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, result.getSignalStrength(), 4));
                        } else if (result.getLteRsrp() != null) {
                            result.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_RSRP, result.getLteRsrp(), 4));
                        } else { // RSSI for Mobile
                            result.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, result.getSignalStrength(), 4));
                        }
                    }
                }
            }

        } catch (Exception ex) {
            log.error("Error: ", ex);
        }
        return dto.build();
    }

    @Override
    public ImageGenerateDto getImageGenerateDto(String lang, String uuid, String size) {
        final String sql = "    SELECT"
                //+ " ('P' || t.open_uuid) open_uuid,"
                //+ " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI') \"time\","
                + " nt.name network_type,"
                //+ " t.geo_provider loc_src,"
                + " t.speed_download download_kbit,"
                + " t.speed_upload upload_kbit,"
                + " (t.ping_median::float / 1000000) ping_ms,"
                + " t.signal_strength,"
                + " COALESCE(prov.shortname, mprov.shortname, prov.name, mprov.name, network_operator_name, network_sim_operator) provider_name,"
                + " COALESCE(t.plattform, t.client_name) as platform "
                //+ " network_operator network_mcc_mnc,"
                //+ " network_operator_name network_name,"
                //+ " network_sim_operator sim_mcc_mnc,"
                //+ " nat_type \"connection\","
                //+ " public_ip_asn asn,"
                //+ " client_public_ip_anonymized ip_anonym,"
                //+ " (ndt.s2cspd*1000)::int ndt_download_kbit,"
                //+ " (ndt.c2sspd*1000)::int ndt_upload_kbit"
                + " FROM test t"
                + " LEFT JOIN network_type nt ON nt.uid=t.network_type"
                + " LEFT JOIN device_map adm ON adm.codename=t.model"
                + " LEFT JOIN test_server ts ON ts.uid=t.server_id"
                + " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id"
                + " LEFT JOIN provider prov ON mobile_provider_id = prov.uid "
                + " LEFT JOIN provider mprov ON provider_id = mprov.uid"
                + " WHERE "
                + " t.deleted = false AND t.implausible = false"
                + " AND status = 'FINISHED'"
                + " AND t.open_test_uuid = ?";

        return jdbcTemplate.query(
                new PreparedStatementCreator() {
                    @Override
                    public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                        return con.prepareStatement(sql);
                    }
                },
                new PreparedStatementSetter() {
                    @Override
                    public void setValues(PreparedStatement ps) throws SQLException {
                        ps.setObject(1, uuid, Types.OTHER);
                    }
                },
                new ResultSetExtractor<ImageGenerateDto>() {
                    @Override
                    public ImageGenerateDto extractData(ResultSet rs) throws SQLException, DataAccessException {
                        if (!rs.next()) {
                            throw new RuntimeException("invalid uuid");
                        }
                        return ImageGenerateDto.builder()
                                .size(size)
                                .lang(lang)
                                .download(((double) rs.getInt("download_kbit")) / 1000)
                                .upload(((double) rs.getInt("upload_kbit")) / 1000)
                                .ping(rs.getFloat("ping_ms"))
                                .isp(rs.getString("provider_name"))
                                .typ(rs.getString("network_type"))
                                .signal(rs.getString("signal_strength"))
                                .os(rs.getString("platform"))
                                .build();
                    }
                });
    }

    @Override
    public OpenTestDetailsDTO getOpenTestByUuid(String openTestUuid, int verbose) {
        final String sql = "SELECT t.uid as test_uid, " +
                " ('P' || t.open_uuid) open_uuid," +  //csv 1:open_uuid, UUID prefixed with 'P'
                " ('O' || t.open_test_uuid) open_test_uuid," + //csv  open_test_uuid, UUID prefixed with 'O'
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
                " t.time full_time," + //csv: 3:time server time-stamp of start of measurement
                " t.client_time client_time," +  //(internal) client time-stamp of start of measure
                " t.network_group_name cat_technology," + //csv 4:cat_technology
                " t.network_group_type network_type," + //csv 5:network_type
                /*
                " t.geo_lat lat," + //csv 6:lat
                " t.geo_long long," + // csv 7:long
                " t.geo_provider loc_src," + //csv 8:loc_src android: 'gps'/'network'; browser/iOS: '' (empty string)
                " t.geo_accuracy loc_accuracy, " + //accuracy of geo location in m
                */
                //csv 6:lat
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " tl.geo_lat" +
                " WHEN (tl.geo_accuracy < ?) THEN" +
                " ROUND(tl.geo_lat*1111)/1111" + // approx 100m
                " ELSE null" +
                " END) latitude," +
                // csv 7:long
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " tl.geo_long" +
                " WHEN (tl.geo_accuracy < ?) THEN" +
                " ROUND(tl.geo_long*741)/741 " + //approx 100m
                " ELSE null" +
                " END) longitude," +
                // csv 8:loc_src android: 'gps'/'network'; browser/iOS: '' (empty string)
                " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
                " 'rastered'" + //make raster transparent
                " ELSE tl.geo_provider" +
                " END) loc_src," +
                // accuracy of geo location in m
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
                " THEN tl.geo_accuracy " +
                " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
                " WHEN (tl.geo_accuracy < ?) THEN tl.geo_accuracy" +
                " ELSE null END) loc_accuracy, " +
                " NULL zip_code," +
                " tl.kg_nr_bev kg_nr," +
                " tl.gkz_bev gkz," +
                " tl.gkz_sa gkz_sa," +
                " tl.land_cover land_cover," +
                " k.kg locality," +
                " k.pg community," +
                " k.pb district," +
                " k.bl province," +
                " NULL cov800cat," +
                " t.speed_download download_kbit," + //csv 10:download_kbit
                " t.speed_upload upload_kbit," + //csv 11: upload_kbit
                " t.wifi_link_speed," + // nominal speed of wifi-link in mbit/s , Android-only
                " (t.ping_median::float / 1000000) ping_ms," + //median ping-time in ms (stored in ns in data base)
                " signal_strength," + //csv 13:signal_strength RSSI, mainly GSM/UMTS and Wifi, Android only, in dBm
                " lte_rsrp," + // csv 29: signal_strength RSRP, Android only, in dBm
                " lte_rsrq," + // signal quality RSRQ, Android only, in dB
                " ts.name server_name," + //csv 14:server_name, name of the test server used for download/upload (not applicable for JStest)
                " implausible, " +  //csv 28:implausible, measurement not shown in map nor used in statistics, normally not visible
                " pinned, " + //true, if test is used in statistics, false if it is a repeated measurement
                " public_ip_as_name, " + //name of AS (not number)
                " duration test_duration," +  //csv 15:test_duration, nominal duration of downlink and uplink throughput tests in seconds
                " num_threads_requested," + // number of threads requested by control-server
                " num_threads," + //csv 16:num_threads, number of threads used in downlink throughput test (uplink may differ)
                " num_threads_ul," + // number of threads used in uplink test
                " COALESCE(t.plattform, t.client_name) as platform," + //csv 17:platform; currently used: 'CLI'/'Android'/Applet/iOS/[from client_name: RMBTws, RMBTjs](null); (null) is used for RMBTjs
                " COALESCE(adm.fullname, t.model) model," + //csv 18:model, translated t.model (model_native) to human readable form
                " t.model model_native," + //device used for test; Android API 'model'; iOS:'product'; Browser: Browser-name (zB Firefox)
                " t.product product," +  // product used for test; Android APO 'product'; iOS: '' (not used); Browser: same as for model (browser name)
                " t.client_software_version client_version," + //csv 19:client_version, SW-version of client software (not RMBT-client-version), eg. '1.3'
                " t.network_operator network_mcc_mnc," + //csv 20:network_mcc_mnc, mobile country and network code of current network (Android only), string, eg "232-12'
                " network_country," + //(internal) Android-only, country code derived by client from mobile network code
                // " network_is_roaming," + //(internal) roaming-status of mobile network, boolean or (null); Android-only (obsolete)
                " roaming_type," + //roaming-status of mobile network, integer: 0:not roaming,1:national,2:international,(null):unknown (eg. iOS)
                " t.network_operator_name network_name," + //csv 21:network_name, name of current mobile network as displayed on device (eg: '3likeHome')
                " t.network_sim_operator sim_mcc_mnc," + //csv 22:sim_mcc_mnc, home network of SIM (initial 5 digits from IMSI), eg '232-01'
                " t.network_sim_country sim_country," + //(internal) Android-only, country derived by client from SIM (country of home network)
                " COALESCE(mprov.name,msim.shortname,msim.name,prov.name) provider_name," +  //pre-defined list of providers (based on provider_id) //TODO replace provider
                " t.nat_type \"connection\"," + //csv 23:connection, translation-mechanism in NAT, eg. nat_local_to_public_ipv4
                " t.public_ip_asn asn," + //csv 24:asn, AS (autonomous system) number, number of public IP network
                " t.client_public_ip_anonymized ip_anonym," +  //csv 25:ip_anonym, anonymized IP of client (IPv4: 8 bits removed, IPv6: 72 bits removed)
                " (ndt.s2cspd*1000)::int ndt_download_kbit," + //csv 26:ndt_download_kbit, result of NDT downlink throughput test kbit/s
                " (ndt.c2sspd*1000)::int ndt_upload_kbit," + //csv 27 ndt_uoload_kbit, result of NDT uplink throughput test in kbit/s
                " country_geoip," + // country-code derived from public IP-address, eg. 'AT'
                " tl.country_location country_location," + // country-code derived from geo_location, eg. 'DE'
                " country_asn," + // country_code derived from AS, eg. 'EU'
                " bytes_download," + // number of bytes downloaded during test (download and upload) (obsolete)
                " bytes_upload," + // number of bytes uploaded during test (download and upload) (obsolete)
                " test_if_bytes_download," + //downloaded bytes on interface during total test (inc. training, ping, without NDT) (obsolete)
                " test_if_bytes_upload," + //uploaded bytes on interface during total test (inc. training, ping, without NDT) (obsolete)
                " testdl_if_bytes_download," + //downloaded bytes on interface during download-test (without training-seq)
                " testdl_if_bytes_upload," + //uploaded bytes on interface during download-test (without training-seq)
                " testul_if_bytes_download," + //downloaded bytes on interface during upload-test (without training-seq)
                " testul_if_bytes_upload," + //downloaded bytes on interface during upload-test (without training-seq)
                " (t.nsec_download::float / 1000000) duration_download_ms," + //duration of download-test in ms
                " (t.nsec_upload::float / 1000000) duration_upload_ms," + //duration of upload-test in ms
                " (t.time_dl_ns::float / 1000000) time_dl_ms," + //relative start time of download-test in ms (ignoring training-phase)
                " (t.time_ul_ns::float / 1000000) time_ul_ms," + //relative start time of download-test in ms (ignoring training-phase)
                // " phone_type" + //(internal) radio type of phone: 0 no mobile radio, 1 GSM (incl. UMTS,LTE) 2 CDMA (obsolete)
                " speed.items speed_items," + // json representation of individual up+down speed items
                " channel_number," +
                " radio_band," +
                " cell_location_id cell_area_code," +
                " cell_area_code cell_location_id," +
                " tl.settlement_type settlement_type" +
                " , tl.link_id link_id" +
                " , tl.link_name link_name" +
                " , tl.link_distance link_distance" +
                " , tl.edge_id edge_id" +
                " , tl.frc link_frc" +
                " , tl.dtm_level dtm_level" +
                " , ln.name1 link_name1" +
                " , ln.name2 link_name2" +
                " FROM test t" +
                " LEFT JOIN device_map adm ON adm.codename=t.model" +
                " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
                " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
                " LEFT JOIN provider prov ON t.provider_id=prov.uid" +
                " LEFT JOIN provider mprov ON t.mobile_provider_id=mprov.uid" +
                " LEFT JOIN mccmnc2name msim ON t.mobile_sim_id=msim.uid" +
                " LEFT JOIN speed ON speed.open_test_uuid=t.open_test_uuid" +
                " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
                " LEFT JOIN bev_vgd k ON tl.kg_nr_bev = k.kg_nr_int" +
                " LEFT JOIN linknet ln on tl.link_id = ln.link_id " +
                " WHERE " +
                " t.deleted = false " +
                " AND t.status = 'FINISHED' " +
                " AND t.open_test_uuid = ? ";

        return jdbcTemplate.query(
                new PreparedStatementCreator() {
                    @Override
                    public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                        return con.prepareStatement(sql);
                    }
                },
                new PreparedStatementSetter() {
                    @Override
                    public void setValues(PreparedStatement ps) throws SQLException {
                        //insert filter for accuracy
                        ps.setDouble(1, Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT);
                        ps.setDouble(2, Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT);
                        ps.setDouble(3, Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT);
                        ps.setDouble(4, Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT);
                        ps.setDouble(5, Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT);
                        ps.setDouble(6, Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT);
                        ps.setObject(7, openTestUuid, Types.OTHER);
                    }
                },
                new ResultSetExtractor<OpenTestDetailsDTO>() {
                    @Override
                    public OpenTestDetailsDTO extractData(ResultSet rs) throws SQLException, DataAccessException {
                        if (!rs.next()) {
                            throw new RuntimeException("invalid uuid");
                        }
                        return OpenTestDetailsDTO.builder()
                                .testUid(rs.getLong("test_uid"))
                                .openUuid(rs.getString("open_uuid"))
                                .openTestUuid(rs.getString("open_test_uuid"))
                                .time(rs.getString("time"))
                                .fullTime(rs.getString("full_time"))
                                .clientTime(rs.getTimestamp("client_time"))
                                .catTechnology(rs.getString("cat_technology"))
                                .networkType(rs.getString("network_type"))
                                .latitude(SqlUtils.getDoubleOrNull(rs, "latitude"))
                                .longitude(SqlUtils.getDoubleOrNull(rs, "longitude"))
                                .locSrc(rs.getString("loc_src"))
                                .locAccuracy(SqlUtils.getDoubleOrNull(rs, "loc_accuracy"))
                                .zipCode(SqlUtils.getLongOrNull(rs, "zip_code"))
                                .kgNr(SqlUtils.getIntegerOrNull(rs, "kg_nr"))
                                .gkz(SqlUtils.getIntegerOrNull(rs, "gkz"))
                                .gkzSa(SqlUtils.getIntegerOrNull(rs, "gkz_sa"))
                                .landCover(SqlUtils.getIntegerOrNull(rs, "land_cover"))
                                .locality(rs.getString("locality"))
                                .community(rs.getString("community"))
                                .district(rs.getString("district"))
                                .province(rs.getString("province"))
                                .downloadKbit(SqlUtils.getIntegerOrNull(rs, "download_kbit"))
                                .uploadKbit(SqlUtils.getIntegerOrNull(rs, "upload_kbit"))
                                .wifiLinkSpeed(SqlUtils.getLongOrNull(rs, "wifi_link_speed"))
                                .pingMs(SqlUtils.getDoubleOrNull(rs, "ping_ms"))
                                .signalStrength(SqlUtils.getIntegerOrNull(rs, "signal_strength"))
                                .lteRsrp(SqlUtils.getIntegerOrNull(rs, "lte_rsrp"))
                                .lteRsrq(SqlUtils.getLongOrNull(rs, "lte_rsrq"))
                                .serverName(rs.getString("server_name"))
                                .implausible(rs.getBoolean("implausible"))
                                .pinned(rs.getBoolean("pinned"))
                                .publicIpAsName(rs.getString("public_ip_as_name"))
                                .testDuration(rs.getLong("test_duration"))
                                .numThreadsRequested(SqlUtils.getLongOrNull(rs, "num_threads_requested"))
                                .numThreads(SqlUtils.getLongOrNull(rs, "num_threads"))
                                .numThreadsUl(SqlUtils.getLongOrNull(rs, "num_threads_ul"))
                                .platform(rs.getString("platform"))
                                .model(rs.getString("model"))
                                .modelNative(rs.getString("model_native"))
                                .product(rs.getString("product"))
                                .clientVersion(rs.getString("client_version"))
                                .networkMccMnc(rs.getString("network_mcc_mnc"))
                                .networkCountry(rs.getString("network_country"))
                                .roamingType(SqlUtils.getLongOrNull(rs, "roaming_type"))
                                .networkName(rs.getString("network_name"))
                                .simMccMnc(rs.getString("sim_mcc_mnc"))
                                .simCountry(rs.getString("sim_country"))
                                .providerName(rs.getString("provider_name"))
                                .connection(rs.getString("connection"))
                                .asn(SqlUtils.getLongOrNull(rs, "asn"))
                                .ipAnonym(rs.getString("ip_anonym"))
                                .ndtDownloadKbit(SqlUtils.getLongOrNull(rs, "ndt_download_kbit"))
                                .ndtUploadKbit(SqlUtils.getLongOrNull(rs, "ndt_upload_kbit"))
                                .countryGeoip(rs.getString("country_geoip"))
                                .countryLocation(rs.getString("country_location"))
                                .countryAsn(rs.getString("country_asn"))
                                .bytesDownload(SqlUtils.getLongOrNull(rs, "bytes_download"))
                                .bytesUpload(SqlUtils.getLongOrNull(rs, "bytes_upload"))
                                .testIfBytesDownload(SqlUtils.getLongOrNull(rs, "test_if_bytes_download"))
                                .testIfBytesUpload(SqlUtils.getLongOrNull(rs, "test_if_bytes_upload"))
                                .testdlIfBytesDownload(SqlUtils.getLongOrNull(rs, "testdl_if_bytes_download"))
                                .testdlIfBytesUpload(SqlUtils.getLongOrNull(rs, "testdl_if_bytes_upload"))
                                .testulIfBytesDownload(SqlUtils.getLongOrNull(rs, "testul_if_bytes_download"))
                                .testulIfBytesUpload(SqlUtils.getLongOrNull(rs, "testul_if_bytes_upload"))
                                .durationDownloadMs(SqlUtils.getDoubleOrNull(rs, "duration_download_ms"))
                                .durationUploadMs(SqlUtils.getDoubleOrNull(rs, "duration_upload_ms"))
                                .timeDlMs(SqlUtils.getDoubleOrNull(rs, "time_dl_ms"))
                                .timeUlMs(SqlUtils.getDoubleOrNull(rs, "time_ul_ms"))
                                .speedItems(rs.getString("speed_items"))
                                .channelNumber(SqlUtils.getLongOrNull(rs, "channel_number"))
                                .radioBand(SqlUtils.getLongOrNull(rs, "radio_band"))
                                .cellAreaCode(SqlUtils.getLongOrNull(rs, "cell_area_code"))
                                .cellLocationId(SqlUtils.getLongOrNull(rs, "cell_location_id"))
                                .settlementType(SqlUtils.getIntegerOrNull(rs, "settlement_type"))
                                .linkId(SqlUtils.getLongOrNull(rs, "link_id"))
                                .linkName(rs.getString("link_name"))
                                .linkDistance(SqlUtils.getIntegerOrNull(rs, "link_distance"))
                                .edgeId(SqlUtils.getLongOrNull(rs, "edge_id"))
                                .linkFrc(SqlUtils.getIntegerOrNull(rs, "link_frc"))
                                .dtmLevel(SqlUtils.getIntegerOrNull(rs, "dtm_level"))
                                .linkName1(rs.getString("link_name1"))
                                .linkName2(rs.getString("link_name2"))
                                .build();
                    }
                }
        );
    }

    private Map<String, Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>>> parseSpeedItems(String speedItemsJson, Integer verboseLevel) {
        ObjectMapper objectMapper = new ObjectMapper();
        SpeedItems speedItems = null;
        try {
            speedItems = objectMapper.readValue(speedItemsJson, SpeedItems.class);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        //threads
        Map<String, Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>>> threadwise = new HashMap<>();


        if (speedItems != null && verboseLevel > 0) {
            Map<String, Map<Integer, List<SpeedItems.SpeedItem>>> rawJSON = speedItems.getRawJSONData();

            //phases
            for (String phase : rawJSON.keySet()) {

                Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>> threads = new HashMap<>();
                threadwise.put(phase, threads);

                for (int thread : rawJSON.get(phase).keySet()) {
                    List<SpeedGraphItemDTO.SpeedItemThreadwise> threadItems = new ArrayList<>();
                    threads.put(String.valueOf(thread), threadItems);

                    //speed items
                    for (SpeedItems.SpeedItem item : rawJSON.get(phase).get(thread)) {
                        SpeedGraphItemDTO.SpeedItemThreadwise measurement = new SpeedGraphItemDTO.SpeedItemThreadwise();
                        measurement.setBytesTotal(item.getBytes());
                        measurement.setTimeElapsed(item.getTime());
                        threadItems.add(measurement);
                    }
                }
            }
        }
        return threadwise;
    }
}