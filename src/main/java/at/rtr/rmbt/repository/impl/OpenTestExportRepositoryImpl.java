package at.rtr.rmbt.repository.impl;

import at.rtr.rmbt.constant.Constants;
import at.rtr.rmbt.dto.OpenTestExportResult;
import at.rtr.rmbt.repository.OpenTestExportRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.stereotype.Service;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
public class OpenTestExportRepositoryImpl implements OpenTestExportRepository {

    private final JdbcTemplate jdbcTemplate;
    private static final String SELECT_BY_MONTH_AND_YEAR = "SELECT" +
            " ('P' || t.open_uuid) open_uuid," +
            " ('O' || t.open_test_uuid) open_test_uuid," +
            " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
            " nt.group_name cat_technology," +
            " nt.name network_type," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_lat" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_lat*1111)/1111" +
            " ELSE null" +
            " END) latitude," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_long" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_long*741)/741 " +
            " ELSE null" +
            " END) longitude," +
            " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
            " 'rastered'" + //make raster transparent
            " ELSE tl.geo_provider" +
            " END) loc_src," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
            " THEN round(tl.geo_accuracy::float * 10)/10 " +
            " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN round(tl.geo_accuracy::float * 10)/10" +
            " ELSE null END) loc_accuracy, " +
            " tl.gkz_bev gkz," +
            " NULL zip_code," +
            " tl.country_location country_location," +
            " t.speed_download download_kbit," +
            " t.speed_upload upload_kbit," +
            " round(t.ping_median::float / 100000)/10 ping_ms," +
            " t.lte_rsrp," +
            " t.lte_rsrq," +
            " ts.name server_name," +
            " duration test_duration," +
            " num_threads," +
            " t.plattform platform," +
            " COALESCE(adm.fullname, t.model) model," +
            " client_software_version client_version," +
            " network_operator network_mcc_mnc," +
            " network_operator_name network_name," +
            " network_sim_operator sim_mcc_mnc," +
            " nat_type," +
            " public_ip_asn asn," +
            " client_public_ip_anonymized ip_anonym," +
            " (ndt.s2cspd*1000)::int ndt_download_kbit," +
            " (ndt.c2sspd*1000)::int ndt_upload_kbit," +
            " COALESCE(t.implausible, false) implausible," +
            " t.signal_strength," +
            " t.pinned pinned," +
            " tl.kg_nr_bev kg_nr," +
            " tl.gkz_sa gkz_sa," +
            " tl.land_cover, " +
            " t.cell_location_id cell_area_code," +
            " t.cell_area_code cell_location_id," +
            " t.channel_number channel_number," +
            " t.radio_band radio_band" +
            " , tl.settlement_type settlement_type" +
            " , tl.link_id link_id" +
            " , tl.link_name link_name" +
            " , tl.link_distance link_distance" +
            " , tl.edge_id edge_id" +
            " , tl.frc link_frc" +
            " , tl.dtm_level dtm_level" +
            " FROM test t" +
            " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
            " LEFT JOIN device_map adm ON adm.codename=t.model" +
            " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
            " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
            " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
            " WHERE " +
            " t.deleted = false " +
            "AND (EXTRACT (month FROM t.time AT TIME ZONE 'UTC') = ?) " +
            "AND (EXTRACT (year FROM t.time AT TIME ZONE 'UTC') = ?) " +
            "AND status = 'FINISHED' " +
            "ORDER BY t.uid";
    private static final String SELECT_BY_HOUR = "SELECT" +
            " ('P' || t.open_uuid) open_uuid," +
            " ('O' || t.open_test_uuid) open_test_uuid," +
            " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
            " nt.group_name cat_technology," +
            " nt.name network_type," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_lat" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_lat*1111)/1111" +
            " ELSE null" +
            " END) latitude," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_long" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_long*741)/741 " +
            " ELSE null" +
            " END) longitude," +
            " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
            " 'rastered'" + //make raster transparent
            " ELSE tl.geo_provider" +
            " END) loc_src," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
            " THEN round(tl.geo_accuracy::float * 10)/10 " +
            " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN round(tl.geo_accuracy::float * 10)/10" +
            " ELSE null END) loc_accuracy, " +
            " tl.gkz_bev gkz," +
            " NULL zip_code," +
            " tl.country_location country_location," +
            " t.speed_download download_kbit," +
            " t.speed_upload upload_kbit," +
            " round(t.ping_median::float / 100000)/10 ping_ms," +
            " t.lte_rsrp," +
            " t.lte_rsrq," +
            " ts.name server_name," +
            " duration test_duration," +
            " num_threads," +
            " t.plattform platform," +
            " COALESCE(adm.fullname, t.model) model," +
            " client_software_version client_version," +
            " network_operator network_mcc_mnc," +
            " network_operator_name network_name," +
            " network_sim_operator sim_mcc_mnc," +
            " nat_type," +
            " public_ip_asn asn," +
            " client_public_ip_anonymized ip_anonym," +
            " (ndt.s2cspd*1000)::int ndt_download_kbit," +
            " (ndt.c2sspd*1000)::int ndt_upload_kbit," +
            " COALESCE(t.implausible, false) implausible," +
            " t.signal_strength," +
            " t.pinned pinned," +
            " tl.kg_nr_bev kg_nr," +
            " tl.gkz_sa gkz_sa," +
            " tl.land_cover, " +
            " t.cell_location_id cell_area_code," +
            " t.cell_area_code cell_location_id," +
            " t.channel_number channel_number," +
            " t.radio_band radio_band" +
            " , tl.settlement_type settlement_type" +
            " , tl.link_id link_id" +
            " , tl.link_name link_name" +
            " , tl.link_distance link_distance" +
            " , tl.edge_id edge_id" +
            " , tl.frc link_frc" +
            " , tl.dtm_level dtm_level" +
            " FROM test t" +
            " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
            " LEFT JOIN device_map adm ON adm.codename=t.model" +
            " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
            " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
            " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
            " WHERE " +
            " t.deleted = false " +
            "AND time > now() - (?||' hours')::INTERVAL " +
            "AND status = 'FINISHED' " +
            "ORDER BY t.uid";
    private static final String SELECT_LAST_31_DAYS = "SELECT" +
            " ('P' || t.open_uuid) open_uuid," +
            " ('O' || t.open_test_uuid) open_test_uuid," +
            " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
            " nt.group_name cat_technology," +
            " nt.name network_type," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_lat" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_lat*1111)/1111" +
            " ELSE null" +
            " END) latitude," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_long" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_long*741)/741 " +
            " ELSE null" +
            " END) longitude," +
            " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
            " 'rastered'" + //make raster transparent
            " ELSE tl.geo_provider" +
            " END) loc_src," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
            " THEN round(tl.geo_accuracy::float * 10)/10 " +
            " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN round(tl.geo_accuracy::float * 10)/10" +
            " ELSE null END) loc_accuracy, " +
            " tl.gkz_bev gkz," +
            " NULL zip_code," +
            " tl.country_location country_location," +
            " t.speed_download download_kbit," +
            " t.speed_upload upload_kbit," +
            " round(t.ping_median::float / 100000)/10 ping_ms," +
            " t.lte_rsrp," +
            " t.lte_rsrq," +
            " ts.name server_name," +
            " duration test_duration," +
            " num_threads," +
            " t.plattform platform," +
            " COALESCE(adm.fullname, t.model) model," +
            " client_software_version client_version," +
            " network_operator network_mcc_mnc," +
            " network_operator_name network_name," +
            " network_sim_operator sim_mcc_mnc," +
            " nat_type," +
            " public_ip_asn asn," +
            " client_public_ip_anonymized ip_anonym," +
            " (ndt.s2cspd*1000)::int ndt_download_kbit," +
            " (ndt.c2sspd*1000)::int ndt_upload_kbit," +
            " COALESCE(t.implausible, false) implausible," +
            " t.signal_strength," +
            " t.pinned pinned," +
            " tl.kg_nr_bev kg_nr," +
            " tl.gkz_sa gkz_sa," +
            " tl.land_cover, " +
            " t.cell_location_id cell_area_code," +
            " t.cell_area_code cell_location_id," +
            " t.channel_number channel_number," +
            " t.radio_band radio_band" +
            " , tl.settlement_type settlement_type" +
            " , tl.link_id link_id" +
            " , tl.link_name link_name" +
            " , tl.link_distance link_distance" +
            " , tl.edge_id edge_id" +
            " , tl.frc link_frc" +
            " , tl.dtm_level dtm_level" +
            " FROM test t" +
            " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
            " LEFT JOIN device_map adm ON adm.codename=t.model" +
            " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
            " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
            " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
            " WHERE " +
            " t.deleted = false " +
            "AND time > current_date - interval '31 days' " +
            "AND status = 'FINISHED' " +
            "ORDER BY t.uid";

    @Override
    public List<OpenTestExportResult> getOpenTestExportHour(Integer hour) {
        PreparedStatementCreator preparedStatementCreator = getPreparedStatementCreator(SELECT_BY_HOUR);
        PreparedStatementSetter preparedStatementSetter = getPreparedStatementSetterHour(hour);
        ResultSetExtractor<List<OpenTestExportResult>> resultSetExtractor = getListResultSetExtractor();
        return jdbcTemplate.query(preparedStatementCreator, preparedStatementSetter, resultSetExtractor);
    }

    @Override
    public List<OpenTestExportResult> getOpenTestExportMonth(Integer year, Integer month) {
        PreparedStatementCreator preparedStatementCreator = getPreparedStatementCreator(SELECT_BY_MONTH_AND_YEAR);
        PreparedStatementSetter preparedStatementSetter = getPreparedStatementSetterMonthAndYear(year, month);
        ResultSetExtractor<List<OpenTestExportResult>> resultSetExtractor = getListResultSetExtractor();
        return jdbcTemplate.query(preparedStatementCreator, preparedStatementSetter, resultSetExtractor);
    }

    @Override
    public List<OpenTestExportResult> getOpenTestExportLast31Days() {
        PreparedStatementCreator preparedStatementCreator = getPreparedStatementCreator(SELECT_LAST_31_DAYS);
        ResultSetExtractor<List<OpenTestExportResult>> resultSetExtractor = getListResultSetExtractor();
        return jdbcTemplate.query(preparedStatementCreator, resultSetExtractor);
    }

    private PreparedStatementSetter getPreparedStatementSetterMonthAndYear(Integer year, Integer month) {
        return new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                ps.setInt(1, month);
                ps.setInt(2, year);
            }
        };
    }

    private PreparedStatementSetter getPreparedStatementSetterHour(Integer hour) {
        return new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                ps.setInt(1, hour);
            }
        };
    }

    private ResultSetExtractor<List<OpenTestExportResult>> getListResultSetExtractor() {
        return new ResultSetExtractor<List<OpenTestExportResult>>() {
            @Override
            public List<OpenTestExportResult> extractData(ResultSet rs) throws SQLException, DataAccessException {
                List<OpenTestExportResult> list = new ArrayList<OpenTestExportResult>();
                while (rs.next()) {
                    OpenTestExportResult openTestExportResult = OpenTestExportResult.builder()
                            .openUuid(rs.getString("open_uuid"))
                            .openTestUuid(rs.getString("open_test_uuid"))
                            .time(rs.getString("time"))
                            .catTechnology(rs.getString("cat_technology"))
                            .networkType(rs.getString("network_type"))
                            .latitude(rs.getObject("latitude", Double.class))
                            .longitude(rs.getObject("longitude", Double.class))
                            .locSrc(rs.getString("loc_src"))
                            .locAccuracy(rs.getObject("loc_accuracy", Double.class))
                            .gkz(rs.getObject("gkz", Integer.class))
                            .zipCode(rs.getString("zip_code"))
                            .countryLocation(rs.getString("country_location"))
                            .downloadKbit(rs.getObject("download_kbit", Integer.class))
                            .uploadKbit(rs.getObject("upload_kbit", Integer.class))
                            .pingMs(rs.getObject("ping_ms", Double.class))
                            .lteRsrp(rs.getObject("lte_rsrp", Integer.class))
                            .lteRsrq(rs.getObject("lte_rsrq", Integer.class))
                            .serverName(rs.getString("server_name"))
                            .testDuration(rs.getObject("test_duration", Integer.class))
                            .numThreads(rs.getObject("num_threads", Integer.class))
                            .platform(rs.getString("platform"))
                            .model(rs.getString("model"))
                            .clientVersion(rs.getString("client_version"))
                            .networkMccMnc(rs.getString("network_mcc_mnc"))
                            .networkName(rs.getString("network_name"))
                            .simMccMnc(rs.getString("sim_mcc_mnc"))
                            .natType(rs.getString("nat_type"))
                            .asn(rs.getObject("asn", Long.class))
                            .ipAnonym(rs.getString("ip_anonym"))
                            .ndtDownloadKbit(rs.getObject("ndt_download_kbit", Integer.class))
                            .ndtUploadKbit(rs.getObject("ndt_upload_kbit", Integer.class))
                            .implausible(rs.getObject("implausible", Boolean.class))
                            .signalStrength(rs.getObject("signal_strength", Integer.class))
                            .pinned(rs.getObject("pinned", Boolean.class))
                            .kgNr(rs.getObject("kg_nr", Integer.class))
                            .gkzSa(rs.getObject("gkz_sa", Integer.class))
                            .landCover(rs.getObject("land_cover", Integer.class))
                            .cellAreaCode(rs.getObject("cell_area_code", Integer.class))
                            .cellLocationId(rs.getObject("cell_location_id", Integer.class))
                            .channelNumber(rs.getObject("channel_number", Integer.class))
                            .radioBand(rs.getObject("radio_band", Integer.class))
                            .settlementType(rs.getObject("settlement_type", Integer.class))
                            .linkId(rs.getObject("link_id", Integer.class))
                            .linkName(rs.getString("link_name"))
                            .linkDistance(rs.getObject("link_distance", Integer.class))
                            .edgeId(rs.getString("edge_id"))
                            .linkFrc(rs.getObject("link_frc", Integer.class))
                            .dtmLevel(rs.getObject("dtm_level", Integer.class))
                            .build();

                    list.add(openTestExportResult);
                }
                return list;
            }
        };
    }

    private PreparedStatementCreator getPreparedStatementCreator(String sql) {
        return new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                return con.prepareStatement(sql);
            }
        };
    }
}
