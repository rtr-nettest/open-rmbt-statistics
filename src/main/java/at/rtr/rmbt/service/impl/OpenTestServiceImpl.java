package at.rtr.rmbt.service.impl;

import at.rtr.rmbt.constant.Constants;
import at.rtr.rmbt.dto.*;
import at.rtr.rmbt.exception.*;
import at.rtr.rmbt.mapper.OpenTestMapper;
import at.rtr.rmbt.repository.GeoAnalyticsRepository;
import at.rtr.rmbt.repository.OpenTestRepository;
import at.rtr.rmbt.request.CapabilitiesRequest;
import at.rtr.rmbt.request.ClassificationRequest;
import at.rtr.rmbt.request.QosRequest;
import at.rtr.rmbt.response.*;
import at.rtr.rmbt.response.opentest.OpenTestDTO;
import at.rtr.rmbt.response.opentest.OpenTestSearchResponse;
import at.rtr.rmbt.service.*;
import at.rtr.rmbt.utils.ConvertUtils;
import at.rtr.rmbt.utils.QueryParser;
import at.rtr.rmbt.utils.smoothing.Smoothable;
import at.rtr.rmbt.utils.smoothing.SmoothingFunction;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.SequenceWriter;
import com.fasterxml.jackson.dataformat.csv.CsvGenerator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.github.sett4.dataformat.xlsx.XlsxMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class OpenTestServiceImpl implements OpenTestService {

    private final CapabilitiesRequest CAPABILITIES = CapabilitiesRequest.builder()
            .rmbtHttp(false)
            .qos(QosRequest.builder().supportsInfo(false).build())
            .classification(ClassificationRequest.builder().count(3).build())
            .build();

    /**
     * data amount for centered moving average must not be < 3 and odd.
     * The function needs x values on the "left" and "right side" of the current value, where x = (SMOOTHING_DATA_AMOUNT-1)/2
     * f(i) = 1/x * (e[i-x] + e[i-x+1] + ... + e[i] + ... + e[i+x-1] + e[i+x])
     */
    public static final int SMOOTHING_DATA_AMOUNT = 5;
    public static final boolean RETURN_SMOOTHED_SPEED_CURVES = false;
    public final int DEFAULT_ROWS = 100; //default number of rows (when max_results is not specified)
    private static final String CSV_FILENAME = "opentests.csv";
    private static final String XLSX_FILENAME = "opentests.xlsx";

    //additional fields that the user is allowed to request
    private final HashSet<String> allowedAdditionalFields = new HashSet<>(Arrays.asList("download_classification", "upload_classification", "ping_classification", "signal_classification"));
    private final OpenTestRepository openTestRepository;
    private final ImageExportService imageExportService;
    private final PingService pingService;
    private final RadioSignalService radioSignalService;
    private final LocationService locationService;
    private final GeoAnalyticsRepository geoAnalyticsRepository;
    private final OpenTestMapper openTestMapper;

    @Override
    public ResponseEntity<Object> searchOpenDataTests(MultiValueMap<String, String> parameters) {
        String format = ObjectUtils.defaultIfNull(parameters.getFirst("format"), "json").toLowerCase();
        OpenTestSearchResponse openTestSearchResults = getOpenTestSearchResponse(parameters);
        ResponseEntity.BodyBuilder representation = ResponseEntity.ok();
        //format, depending on output format
        try {
            if (format.equals("csv")) {
                return getCsvResponseEntity(openTestSearchResults, representation);
            } else if (format.equals("xlsx")) {
                return getXlsxResponseEntity(openTestSearchResults, representation);
            } else {
                return getJsonResponseEntity(openTestSearchResults, representation);
            }
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return ResponseEntity.badRequest().build();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return representation.build();
    }

    @Override
    public ResponseEntity<Object> retrievePng(String lang, String openTestUuid, String size) {
        final String uuid = openTestUuid.substring(1); //since the first letter is a 'O'

        if (!lang.equals("de") && !lang.equals("en")) {
            throw new InvalidLanguageException("invalid language");
        }

        if (!size.equals("forumlarge") && !size.equals("forumsmall") && !size.equals("thumbnail")) {
            throw new InvalidImageTypeException("invalid image type");
        }
        ImageGenerateDto imageGenerateDto = null;
        try {
            imageGenerateDto = openTestRepository.getImageGenerateDto(lang, uuid, size);
        } catch (Exception e) {
            throw new InvalidUuidException("invalid uuid");
        }
        byte[] output = imageExportService.generateImage(imageGenerateDto);

        return ResponseEntity.ok()
                .contentType(new MediaType("image", "png"))
                .body(output);
    }

    @Override
    public OpenTestDetailsDtoResponse getOpenTestByUuid(String openTestUuid, String verbose) {
        int verboseLevel = parseVerboseLevel(verbose);
        OpenTestDetailsDtoResponse dto = new OpenTestDetailsDtoResponse();
        try {
            String formattedOpenTestUuid = ConvertUtils.formatOpenTestUuid(openTestUuid);
            OpenTestDetailsDTO openTestDetailsDTO = openTestRepository.getOpenTestByUuid(formattedOpenTestUuid);

            if (Objects.nonNull(openTestDetailsDTO)) {
                OpenTestDetailsDtoResponse updatedDto = openTestMapper.toOpenTestDetailsDTOResponse(dto, openTestDetailsDTO);
                setClassification(updatedDto);
                setSpeedCurve(verboseLevel, formattedOpenTestUuid, openTestDetailsDTO, updatedDto);
                setDistance(formattedOpenTestUuid, updatedDto);
                return updatedDto;

            } else {
                dto.setError("invalid open-uuid");
            }
        } catch (Exception e) {
            log.info("Exception", e);
            dto.setError("invalid open-uuid");
            log.error("Error occurred: ", e);
            throw new NotFoundExceptionWithObject(dto);
        }

        return dto;
    }

    private void setDistance(String formattedOpenTestUuid, OpenTestDetailsDtoResponse dto) {
        //get movement during test
        TestDistance dist = geoAnalyticsRepository.getTestDistance(UUID.fromString(formattedOpenTestUuid));
        if ((dist != null) && (dist.getTotalDistance() > 0) && dist.getTotalDistance() <= Constants.RMBT_GEO_DISTANCE_DETAIL_LIMIT) {
            dto.setDistance(dist.getTotalDistance());
        }
    }

    private void setSpeedCurve(int verboseLevel, String formattedOpenTestUuid, OpenTestDetailsDTO openTestDetailsDTO, OpenTestDetailsDtoResponse dto) {
        OpenTestGraphDTO graphs = new OpenTestGraphDTO();
        if (Objects.nonNull(openTestDetailsDTO.getSpeedItems())) {
            ObjectMapper objectMapper = new ObjectMapper();
            SpeedItems speedItems = null;
            try {
                speedItems = objectMapper.readValue(openTestDetailsDTO.getSpeedItems(), SpeedItems.class);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
            getOpenTestGraphDTO(graphs, verboseLevel, formattedOpenTestUuid, openTestDetailsDTO, dto, speedItems);
        }
        dto.setSpeedCurve(graphs);
    }

    private OpenTestGraphDTO getOpenTestGraphDTO(OpenTestGraphDTO graphs, int verboseLevel, String formattedOpenTestUuid, OpenTestDetailsDTO openTestDetailsDTO, OpenTestDetailsDtoResponse dto, SpeedItems speedItems) {
        setSpeeds(speedItems, graphs);
        //if verbose - also add raw json data
        if (verboseLevel > 0) {
            setSpeedCurveThreadwise(dto, speedItems);
        }
        setPing(formattedOpenTestUuid, graphs);
        setSignal(formattedOpenTestUuid, openTestDetailsDTO, graphs);
        setLocation(openTestDetailsDTO, graphs);
        return graphs;
    }

    private void setLocation(OpenTestDetailsDTO openTestDetailsDTO, OpenTestGraphDTO graphs) {
        LocationGraphDTO locGraph = locationService.getLocationGraph(openTestDetailsDTO.getTestUid(), openTestDetailsDTO.getClientTime().getTime());
        graphs.setLocation(locGraph.getLocations());
    }

    private void setSignal(String formattedOpenTestUuid, OpenTestDetailsDTO openTestDetailsDTO, OpenTestGraphDTO graphs) {
        List<SignalGraphItemDTO> radioSignalGraph = radioSignalService.getRadioSignalGraph(UUID.fromString(formattedOpenTestUuid), openTestDetailsDTO.getClientTime().getTime());
        graphs.setSignal(radioSignalGraph);
    }

    private void setPing(String formattedOpenTestUuid, OpenTestGraphDTO graphs) {
        List<PingGraphItemDTO> pingGraph = pingService.getPingGraph(UUID.fromString(formattedOpenTestUuid));
        graphs.setPing(pingGraph);
    }

    private void setSpeedCurveThreadwise(OpenTestDetailsDtoResponse dto, SpeedItems speedItems) {
        if (speedItems != null) {
            Map<String, Map<Integer, List<SpeedItems.SpeedItem>>> rawJSON = speedItems.getRawJSONData();

            //threads
            Map<String, Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>>> threadwise = new HashMap<>();

            //phases
            for (String phase : rawJSON.keySet()) {

                Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>> threads = new HashMap<>();
                threadwise.put(phase, threads);

                for (int thread : rawJSON.get(phase).keySet()) {
                    List<SpeedGraphItemDTO.SpeedItemThreadwise> threadItems = new ArrayList<>();
                    threads.put(String.valueOf(thread), threadItems);

                    //speed items
                    for (SpeedItems.SpeedItem item : rawJSON.get(phase).get(thread)) {
                        SpeedGraphItemDTO.SpeedItemThreadwise measurement = new SpeedGraphItemDTO.SpeedItemThreadwise();
                        measurement.setBytesTotal(item.getBytes());
                        measurement.setTimeElapsed(item.getTime());
                        threadItems.add(measurement);
                    }
                }
            }

            dto.setSpeedCurveThreadwise(threadwise);
        }
    }

    private void setSpeeds(SpeedItems speedItems, OpenTestGraphDTO graphs) {
        if (speedItems != null) {
            long lastTime = -1;
            final List<SpeedItems.SpeedItem> uploadList = speedItems.getAccumulatedSpeedItemsUpload();
            final List<SpeedItems.SpeedItem> downloadList = speedItems.getAccumulatedSpeedItemsDownload();
            List<SpeedGraphItemDTO> downloadSpeeds = new ArrayList<>();
            List<SpeedGraphItemDTO> uploadSpeeds = new ArrayList<>();

            if (!RETURN_SMOOTHED_SPEED_CURVES) {
                processSpeedItems(lastTime, uploadList, uploadSpeeds);
                lastTime = -1;
                processSpeedItems(lastTime, downloadList, downloadSpeeds);
            } else {
                final List<? extends Smoothable> smoothedUploadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, uploadList, SMOOTHING_DATA_AMOUNT);
                final List<? extends Smoothable> smoothedDownloadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, downloadList, SMOOTHING_DATA_AMOUNT);
                lastTime = -1;
                processSmoothedSpeedItems(lastTime, uploadSpeeds, smoothedUploadList, 1000000);
                lastTime = -1;
                processSmoothedSpeedItems(lastTime, downloadSpeeds, smoothedDownloadList, 1e6);
            }
            graphs.setDownload(downloadSpeeds);
            graphs.setUpload(uploadSpeeds);
        }
    }

    private void processSmoothedSpeedItems(long lastTime, List<SpeedGraphItemDTO> speeds, List<? extends Smoothable> smoothedList, double i) {
        SpeedGraphItemDTO obj;
        for (Smoothable item : smoothedList) {
            obj = new SpeedGraphItemDTO();
            final long time = Math.round((double) item.getXValue() / i);
            if (time == lastTime)
                continue;
            obj.setTimeElapsed(time);
            obj.setBytesTotal(item.getYValue());
            speeds.add(obj);
        }
    }

    private void processSpeedItems(long lastTime, List<SpeedItems.SpeedItem> uploadList, List<SpeedGraphItemDTO> uploadSpeeds) {
        SpeedGraphItemDTO obj;
        for (SpeedItems.SpeedItem item : uploadList) {
            obj = new SpeedGraphItemDTO();
            final long time = Math.round((double) item.getTime() / 1e6);
            if (time == lastTime)
                continue;
            obj.setTimeElapsed(item.getTime());
            obj.setBytesTotal(item.getBytes());
            uploadSpeeds.add(obj);
            lastTime = time;
        }
    }

    private void setClassification(OpenTestDetailsDtoResponse dto) {
        dto.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, dto.getDownloadKbit(), CAPABILITIES.getClassification().getCount()));
        dto.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, dto.getUploadKbit(), CAPABILITIES.getClassification().getCount()));
        dto.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(dto.getPingMs() * 1000000), CAPABILITIES.getClassification().getCount()));

        //classify signal accordingly
        if ((dto.getSignalStrength() != null || dto.getLteRsrp() != null)
                && dto.getNetworkType() != null) { // signal available
            if (dto.getLteRsrp() == null) { // use RSSI
                if (dto.getNetworkType().equals("WLAN")) { // RSSI for Wifi
                    dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, dto.getSignalStrength(), CAPABILITIES.getClassification().getCount()));
                } else { // RSSI for Mobile
                    dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, dto.getSignalStrength(), CAPABILITIES.getClassification().getCount()));
                }
            } else // RSRP for LTE
                dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_RSRP, dto.getLteRsrp(), CAPABILITIES.getClassification().getCount()));
        } else { // no signal available
            dto.setSignalClassification(null);
        }
    }

    private Integer parseVerboseLevel(String verbose) {
        return Optional.ofNullable(verbose)
                .map(x -> {
                    try {
                        return Integer.parseInt(x);
                    } catch (NumberFormatException ex) {
                        log.info("invalid non-numberic verbosity level");
                    }
                    return null;
                })
                .orElse(0);
    }

    private ResponseEntity<Object> getJsonResponseEntity(OpenTestSearchResponse openTestSearchResults, ResponseEntity.BodyBuilder representation) throws JsonProcessingException {
        ObjectMapper om = new ObjectMapper();
        om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        return representation
                .contentType(new MediaType("application", "json", StandardCharsets.UTF_8))
                .body(om.writer().writeValueAsString(openTestSearchResults));
    }

    private ResponseEntity<Object> getXlsxResponseEntity(OpenTestSearchResponse openTestSearchResults, ResponseEntity.BodyBuilder representation) throws IOException {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        XlsxMapper mapper = new XlsxMapper();
        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        CsvSchema schema = mapper.schemaFor(OpenTestDTO.class).withHeader();
        SequenceWriter sequenceWriter = mapper.writer(schema).writeValues(outputStream);
        sequenceWriter.writeAll(openTestSearchResults.getResults());
        sequenceWriter.flush();
        sequenceWriter.close();
        return representation
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + XLSX_FILENAME)
                .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                .body(outputStream.toByteArray());
    }

    private ResponseEntity<Object> getCsvResponseEntity(OpenTestSearchResponse openTestSearchResults, ResponseEntity.BodyBuilder representation) throws JsonProcessingException {
        CsvMapper cm = new CsvMapper();
        cm.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        cm.enable(CsvGenerator.Feature.STRICT_CHECK_FOR_QUOTING);
        CsvSchema schema = CsvSchema.builder().setLineSeparator("\r\n").setUseHeader(true)
                .addColumnsFrom(cm.schemaFor(OpenTestDTO.class)).build();
        return representation
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + CSV_FILENAME)
                .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                .body(cm.writer(schema).writeValueAsString(openTestSearchResults.getResults()));
    }

    private OpenTestSearchResponse getOpenTestSearchResponse(MultiValueMap<String, String> parameters) {
        final Set<String> additionalFields;
        final List<String> invalidElements = new ArrayList<>();
        final QueryParser qp = new QueryParser();
        qp.parseQuery(parameters);

        //calculate offset
        long offset = -1;
        if (Objects.nonNull(parameters.getFirst("cursor"))) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            offset = Long.parseLong(parameters.getFirst("cursor"));
        }

        //get maximal results-parameter
        long maxrows = DEFAULT_ROWS;
        if (Objects.nonNull(parameters.getFirst("max_results"))) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            maxrows = Long.parseLong(parameters.getFirst("max_results"));
        }

        //parse additional fields
        if (Objects.nonNull(parameters.getFirst("additional_info[]")) || Objects.nonNull(parameters.getFirst("additional_info"))) {
            List<String> param = Objects.nonNull(parameters.getFirst("additional_info[]")) ? parameters.get("additional_info[]") : parameters.get("additional_info");
            for (String field : param) {
                if (!allowedAdditionalFields.contains(field)) {
                    invalidElements.add("additional_info");
                }
            }
            additionalFields = new HashSet<>(param);
        } else {
            additionalFields = new HashSet<>();
        }

        //if there have been errors => inform the user
        if (invalidElements.size() > 0) {
            throw new InvalidFieldsException(invalidElements);
        }

        return openTestRepository.getOpenTestSearchResults(qp, offset, maxrows, additionalFields);
    }
}
