package at.rtr.rmbt.service.impl;

import at.rtr.rmbt.constant.Constants;
import at.rtr.rmbt.dto.*;
import at.rtr.rmbt.exception.*;
import at.rtr.rmbt.mapper.OpenTestMapper;
import at.rtr.rmbt.repository.*;
import at.rtr.rmbt.request.CapabilitiesRequest;
import at.rtr.rmbt.request.ClassificationRequest;
import at.rtr.rmbt.request.QosRequest;
import at.rtr.rmbt.response.*;
import at.rtr.rmbt.response.histogram.BucketResponse;
import at.rtr.rmbt.response.histogram.HistogramResponse;
import at.rtr.rmbt.response.opentest.OpenTestDTO;
import at.rtr.rmbt.response.opentest.OpenTestSearchResponse;
import at.rtr.rmbt.service.*;
import at.rtr.rmbt.utils.ConvertUtils;
import at.rtr.rmbt.utils.QueryParser;
import at.rtr.rmbt.utils.smoothing.Smoothable;
import at.rtr.rmbt.utils.smoothing.SmoothingFunction;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.SequenceWriter;
import com.fasterxml.jackson.dataformat.csv.CsvGenerator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.github.sett4.dataformat.xlsx.XlsxMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class OpenTestServiceImpl implements OpenTestService {

    private final CapabilitiesRequest CAPABILITIES = CapabilitiesRequest.builder()
            .rmbtHttp(false)
            .qos(QosRequest.builder().supportsInfo(false).build())
            .classification(ClassificationRequest.builder().count(3).build())
            .build();

    /**
     * data amount for centered moving average must not be < 3 and odd.
     * The function needs x values on the "left" and "right side" of the current value, where x = (SMOOTHING_DATA_AMOUNT-1)/2
     * f(i) = 1/x * (e[i-x] + e[i-x+1] + ... + e[i] + ... + e[i+x-1] + e[i+x])
     */
    public static final int SMOOTHING_DATA_AMOUNT = 5;
    public static final boolean RETURN_SMOOTHED_SPEED_CURVES = false;
    public final int DEFAULT_ROWS = 100; //default number of rows (when max_results is not specified)
    private static final String CSV_FILENAME = "opentests.csv";
    private static final String XLSX_FILENAME = "opentests.xlsx";

    //additional fields that the user is allowed to request
    private final HashSet<String> allowedAdditionalFields = new HashSet<>(Arrays.asList("download_classification", "upload_classification", "ping_classification", "signal_classification"));
    private final OpenTestRepository openTestRepository;
    private final ImageExportService imageExportService;
    private final PingService pingService;
    private final RadioSignalService radioSignalService;
    private final LocationService locationService;
    private final GeoAnalyticsRepository geoAnalyticsRepository;
    private final OpenTestMapper openTestMapper;
    private final ChoicesRepository choicesRepository;
    private final OpenTestStatisticsRepository openTestStatisticsRepository;
    private final HourlyStatisticRepository hourlyStatisticRepository;
    private final HistogramRepository histogramRepository;
    private final int FINEMULTIPLIER = 10;
    private final int HISTOGRAMDOWNLOADDEFAULTMAX = 100000;
    private final int HISTOGRAMDOWNLOADDEFAULTMIN = 0;
    private final int HISTOGRAMUPLOADDEFAULTMAX = 100000;
    private final int HISTOGRAMUPLOADDEFAULTMIN = 0;
    private final int HISTOGRAMPINGDEFAULTMAX = 300; //milliseconds
    private final int HISTOGRAMPINGDEFAULTMIN = 0;
    private final FencesService fencesService;

    @Override
    public ResponseEntity<Object> searchOpenDataTests(MultiValueMap<String, String> parameters) {
        String format = ObjectUtils.defaultIfNull(parameters.getFirst("format"), "json").toLowerCase();
        OpenTestSearchResponse openTestSearchResults = getOpenTestSearchResponse(parameters);
        ResponseEntity.BodyBuilder representation = ResponseEntity.ok();
        //format, depending on output format
        try {
            if (format.equals("csv")) {
                return getCsvResponseEntity(openTestSearchResults, representation);
            } else if (format.equals("xlsx")) {
                return getXlsxResponseEntity(openTestSearchResults, representation);
            } else {
                return getJsonResponseEntity(openTestSearchResults, representation);
            }
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return ResponseEntity.badRequest().build();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return representation.build();
    }

    @Override
    public ResponseEntity<Object> retrievePng(String lang, String openTestUuid, String size) {
        final String uuid = openTestUuid.substring(1); //since the first letter is a 'O'

        if (!lang.equals("de") && !lang.equals("en")) {
            throw new InvalidLanguageException("invalid language");
        }

        if (!size.equals("forumlarge") && !size.equals("forumsmall") && !size.equals("thumbnail")) {
            throw new InvalidImageTypeException("invalid image type");
        }
        ImageGenerateDto imageGenerateDto = null;
        try {
            imageGenerateDto = openTestRepository.getImageGenerateDto(lang, uuid, size);
        } catch (Exception e) {
            throw new InvalidUuidException("invalid uuid");
        }
        byte[] output = imageExportService.generateImage(imageGenerateDto);

        return ResponseEntity.ok()
                .contentType(new MediaType("image", "png"))
                .body(output);
    }

    @Override
    public OpenTestDetailsDtoResponse getOpenTestByUuid(String openTestUuid, String verbose) {
        int verboseLevel = parseVerboseLevel(verbose);
        OpenTestDetailsDtoResponse dto = new OpenTestDetailsDtoResponse();
        try {
            String formattedOpenTestUuid = ConvertUtils.formatOpenTestUuid(openTestUuid);
            OpenTestDetailsDTO openTestDetailsDTO = openTestRepository.getOpenTestByUuid(formattedOpenTestUuid);

            if (Objects.nonNull(openTestDetailsDTO)) {
                OpenTestDetailsDtoResponse updatedDto = openTestMapper.toOpenTestDetailsDTOResponse(dto, openTestDetailsDTO);
                setClassification(updatedDto);
                setSpeedCurve(verboseLevel, formattedOpenTestUuid, openTestDetailsDTO, updatedDto);
                setDistance(formattedOpenTestUuid, updatedDto);
                return updatedDto;

            } else {
                dto.setError("invalid open-uuid");
            }
        } catch (Exception e) {
            log.info("Exception", e);
            dto.setError("invalid open-uuid");
            log.error("Error occurred: ", e);
            throw new NotFoundExceptionWithObject(dto);
        }

        return dto;
    }

    @Override
    public ChoicesResponse getChoices(MultiValueMap<String, String> parameters) {
        final QueryParser queryParser = new QueryParser();
        queryParser.parseQuery(parameters);
        Set<String> countryMobile = choicesRepository.findCountryMobile(queryParser);
        Set<String> providerMobile = choicesRepository.findProviderMobile(queryParser);
        Set<String> provider = choicesRepository.findProvider(queryParser);
        return new ChoicesResponse(countryMobile,
                providerMobile,
                provider);
    }

    @Override
    @Cacheable(value = Constants.OPENTESTS_STATISTIC_CACHE_NAME)
    public Map<String, Long> getStatistics(MultiValueMap<String, String> parameters) {
        final QueryParser qp = new QueryParser();
        // set transformator for time to allow for broader caching (a few
        // minutes)
        qp.registerSingleParameterTransformator("time",
                new QueryParser.SingleParameterTransformator() {
                    private final static int FEW_MINUTES = 60 * 1 * 1000;

                    @Override
                    public void transform(QueryParser.SingleParameter param) {
                        // round to 1h
                        long timestamp = Long.parseLong(param.getValue());
                        timestamp = timestamp - (timestamp % FEW_MINUTES);
                        param.setValue(Long.toString(timestamp));
                    }
                });

        qp.parseQuery(parameters);
        return openTestStatisticsRepository.calculateStatistics(qp);
    }

    @Override
    @Cacheable(value = Constants.OPENTESTS_INTRADAY_CACHE_NAME)
    public List<HourlyStatisticResponse> getIntraday(MultiValueMap<String, String> parameters) {
        QueryParser queryParser = new QueryParser();
        queryParser.getAllowedFields().put("quantile", QueryParser.FieldType.IGNORE);

        double quantile = 0.5;
        if (parameters.containsKey("quantile")) {
            try {
                quantile = Double.parseDouble(parameters.getFirst("quantile"));
                quantile = Math.min(quantile, 1);
                quantile = Math.max(quantile, 0);
            } catch (NumberFormatException e) {
            }
        }

        //set transformator for time to allow for broader caching
        queryParser.registerSingleParameterTransformator("time", new QueryParser.SingleParameterTransformator() {
            private final static int ONE_HOUR = 60 * 60 * 1000;

            @Override
            public void transform(QueryParser.SingleParameter param) {
                //round to 1h
                long timestamp = Long.parseLong(param.getValue());
                timestamp = timestamp - (timestamp % ONE_HOUR);
                param.setValue(Long.toString(timestamp));
            }
        });

        queryParser.parseQuery(parameters);

        return hourlyStatisticRepository.getHourlyStatistic(queryParser, quantile);
    }

    @Override
    @Cacheable(Constants.OPENTESTS_HISTOGRAM_CACHE_NAME)
    public HistogramResponse getHistogram(MultiValueMap<String, String> parameters) {
        final QueryParser qp = new QueryParser();

        //set transformator for time to allow for broader caching
        qp.registerSingleParameterTransformator("time", new QueryParser.SingleParameterTransformator() {
            private final static int ONE_HOUR = 60 * 60 * 1000;

            @Override
            public void transform(QueryParser.SingleParameter param) {
                //round to 1h
                long timestamp = Long.parseLong(param.getValue());
                timestamp = timestamp - (timestamp % ONE_HOUR);
                param.setValue(Long.toString(timestamp));
            }
        });

        //also allow doing histogram just for single fields
        List<String> measurements = new LinkedList<>();
        qp.getAllowedFields().put("measurement", QueryParser.FieldType.IGNORE);
        qp.getAllowedFields().put("measurement[]", QueryParser.FieldType.IGNORE);
        if (parameters.containsKey("measurement") ||
                parameters.containsKey("measurement[]")) {
            List<String> measurementArray = parameters.get("measurement");
            if (measurementArray.size() == 0) {
                measurementArray = parameters.get("measurement[]");
            }

            for (String singleMeasurement : measurementArray) {
                if (singleMeasurement.matches("download|upload|ping")) {
                    measurements.add(singleMeasurement);
                }
            }
        } else {
            measurements.addAll(Arrays.asList("download", "upload", "ping"));
        }
        qp.parseQuery(parameters);
        HistogramInfo histogramInfo = new HistogramInfo();
        adjustHistogramInfo(qp, histogramInfo);

        return buildHistogram(qp, measurements, histogramInfo);
    }

    private HistogramResponse buildHistogram(QueryParser qp, List<String> measurements, HistogramInfo histogramInfo) {
        HistogramResponse.HistogramResponseBuilder ret = HistogramResponse.builder();
        boolean logarithmic;
        double min, max;

        //Download
        if (measurements.contains("download")) {
            // logarithmic if without filters
            logarithmic = false;
            if (histogramInfo.max_download == Long.MIN_VALUE
                    && histogramInfo.min_download == Long.MIN_VALUE) {

                histogramInfo.max_download = 1;
                histogramInfo.min_download = 0;
                logarithmic = true;
            }
            if (!logarithmic && histogramInfo.max_download == Long.MIN_VALUE) {
                histogramInfo.max_download = HISTOGRAMDOWNLOADDEFAULTMAX;
            }
            if (!logarithmic && histogramInfo.min_download == Long.MIN_VALUE) {
                histogramInfo.min_download = HISTOGRAMDOWNLOADDEFAULTMIN;
            }
            min = histogramInfo.min_download;
            max = histogramInfo.max_download;
            List<BucketResponse> downArrayfine = histogramRepository.getJSONForHistogram(min, max,
                    (logarithmic) ? "speed_download_log" : "speed_download",
                    logarithmic, qp);
            List<BucketResponse> downArrayLowRes = getLowResBucketList(downArrayfine);

            ret.downloadKbit(downArrayLowRes);
            ret.downloadKbitFine(downArrayfine);
        }

        // Upload
        if (measurements.contains("upload")) {
            logarithmic = false;
            if (histogramInfo.max_upload == Long.MIN_VALUE
                    && histogramInfo.min_upload == Long.MIN_VALUE) {
                histogramInfo.max_upload = 1;
                histogramInfo.min_upload = 0;
                logarithmic = true;
            }
            if (!logarithmic && histogramInfo.max_upload == Long.MIN_VALUE) {
                histogramInfo.max_upload = HISTOGRAMUPLOADDEFAULTMAX;
            }
            if (!logarithmic && histogramInfo.min_upload == Long.MIN_VALUE) {
                histogramInfo.min_upload = HISTOGRAMUPLOADDEFAULTMIN;
            }
            min = histogramInfo.min_upload;
            max = histogramInfo.max_upload;
            List<BucketResponse> uploadBucketsfine = histogramRepository.getJSONForHistogram(min, max,
                    (logarithmic) ? "speed_upload_log" : "speed_upload",
                    logarithmic, qp);

            List<BucketResponse> uploadBucketsLowRes = getLowResBucketList(uploadBucketsfine);

            ret.uploadKbit(uploadBucketsLowRes);
            ret.uploadKbitFine(uploadBucketsfine);
        }

        //Ping
        if (measurements.contains("ping")) {
            if (histogramInfo.max_ping == Long.MIN_VALUE) {
                histogramInfo.max_ping = HISTOGRAMPINGDEFAULTMAX;
            }
            if (histogramInfo.min_ping == Long.MIN_VALUE) {
                histogramInfo.min_ping = HISTOGRAMPINGDEFAULTMIN;
            }
            min = histogramInfo.min_ping;
            max = histogramInfo.max_ping;
            List<BucketResponse> pingArrayH = histogramRepository.getJSONForHistogram(min, max, "(t.ping_median::float / 1000000)", false, qp);
            List<BucketResponse> pingArrayL = getLowResBucketList(pingArrayH);

            ret.pingMs(pingArrayL);
            ret.pingMsFine(pingArrayH);
        }

        return ret.build();
    }

    private List<BucketResponse> getLowResBucketList(List<BucketResponse> fineList) {
        List<BucketResponse> ret = new ArrayList<>();
        BucketResponse currentBucket = new BucketResponse();
        for (int i = 0; i < fineList.size(); i++) {
            if (i % FINEMULTIPLIER == 0) {
                currentBucket = new BucketResponse();
                ret.add(currentBucket);
                currentBucket.lowerBound = fineList.get(i).lowerBound;
            }
            currentBucket.results += fineList.get(i).results;
            if (i % FINEMULTIPLIER == (FINEMULTIPLIER - 1)) {
                currentBucket.upperBound = fineList.get(i).upperBound;
                currentBucket = null;
            }
        }

        return ret;
    }

    private void adjustHistogramInfo(QueryParser qp, HistogramInfo histogramInfo) {
        //adjust HistogramInfo based on given parameters

        //download
        if (qp.getWhereParams().containsKey("download_kbit")) {
            for (QueryParser.SingleParameter param : qp.getWhereParams().get("download_kbit")) {
                switch (param.getComperator()) {
                    case ">=":
                        histogramInfo.min_download = Long.parseLong(param.getValue());
                        break;
                    case "<=":
                        histogramInfo.max_download = Long.parseLong(param.getValue());
                        break;
                }
            }
        }

        //upload
        if (qp.getWhereParams().containsKey("upload_kbit")) {
            for (QueryParser.SingleParameter param : qp.getWhereParams().get("upload_kbit")) {
                switch (param.getComperator()) {
                    case ">=":
                        histogramInfo.min_upload = Long.parseLong(param.getValue());
                        break;
                    case "<=":
                        histogramInfo.max_upload = Long.parseLong(param.getValue());
                        break;
                }
            }
        }

        //ping
        if (qp.getWhereParams().containsKey("ping_ms")) {
            for (QueryParser.SingleParameter param : qp.getWhereParams().get("ping_ms")) {
                switch (param.getComperator()) {
                    case ">=":
                        histogramInfo.min_ping = Double.parseDouble(param.getValue());
                        break;
                    case "<=":
                        histogramInfo.max_ping = Double.parseDouble(param.getValue());
                        break;
                }
            }
        }
    }

    private void setDistance(String formattedOpenTestUuid, OpenTestDetailsDtoResponse dto) {
        //get movement during test
        TestDistance dist = geoAnalyticsRepository.getTestDistance(UUID.fromString(formattedOpenTestUuid));
        if ((dist != null) && (dist.getTotalDistance() > 0) && dist.getTotalDistance() <= Constants.RMBT_GEO_DISTANCE_DETAIL_LIMIT) {
            dto.setDistance(dist.getTotalDistance());
        }
    }

    private void setSpeedCurve(int verboseLevel, String formattedOpenTestUuid, OpenTestDetailsDTO openTestDetailsDTO, OpenTestDetailsDtoResponse dto) {
        OpenTestGraphDTO graphs = new OpenTestGraphDTO();
        if (Objects.nonNull(openTestDetailsDTO.getSpeedItems())) {
            ObjectMapper objectMapper = new ObjectMapper();
            SpeedItems speedItems = null;
            try {
                speedItems = objectMapper.readValue(openTestDetailsDTO.getSpeedItems(), SpeedItems.class);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
            getOpenTestGraphDTO(graphs, verboseLevel, formattedOpenTestUuid, openTestDetailsDTO, dto, speedItems);
        }
        dto.setSpeedCurve(graphs);
    }

    private OpenTestGraphDTO getOpenTestGraphDTO(OpenTestGraphDTO graphs, int verboseLevel, String formattedOpenTestUuid, OpenTestDetailsDTO openTestDetailsDTO, OpenTestDetailsDtoResponse dto, SpeedItems speedItems) {
        setSpeeds(speedItems, graphs);
        //if verbose - also add raw json data
        if (verboseLevel > 0) {
            setSpeedCurveThreadwise(dto, speedItems);
        }
        setPing(formattedOpenTestUuid, graphs);
        setFences(formattedOpenTestUuid, graphs);
        setSignal(formattedOpenTestUuid, openTestDetailsDTO, graphs);
        setLocation(openTestDetailsDTO, graphs);
        return graphs;
    }

    private void setLocation(OpenTestDetailsDTO openTestDetailsDTO, OpenTestGraphDTO graphs) {
        LocationGraphDTO locGraph = locationService.getLocationGraph(openTestDetailsDTO.getTestUid(), openTestDetailsDTO.getClientTime().getTime());
        graphs.setLocation(locGraph.getLocations());
    }

    private void setSignal(String formattedOpenTestUuid, OpenTestDetailsDTO openTestDetailsDTO, OpenTestGraphDTO graphs) {
        List<SignalGraphItemDTO> radioSignalGraph = radioSignalService.getRadioSignalGraph(UUID.fromString(formattedOpenTestUuid), openTestDetailsDTO.getClientTime().getTime());
        graphs.setSignal(radioSignalGraph);
    }

    private void setPing(String formattedOpenTestUuid, OpenTestGraphDTO graphs) {
        List<PingGraphItemDTO> pingGraph = pingService.getPingGraph(UUID.fromString(formattedOpenTestUuid));
        graphs.setPing(pingGraph);
    }

    private void setFences(String formattedOpenTestUuid, OpenTestGraphDTO graphs) {
        List<FencesItemDTO> fences = fencesService.getFences(UUID.fromString(formattedOpenTestUuid));
        graphs.setFences(fences);
    }

    private void setSpeedCurveThreadwise(OpenTestDetailsDtoResponse dto, SpeedItems speedItems) {
        if (speedItems != null) {
            Map<String, Map<Integer, List<SpeedItems.SpeedItem>>> rawJSON = speedItems.getRawJSONData();

            //threads
            Map<String, Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>>> threadwise = new HashMap<>();

            //phases
            for (String phase : rawJSON.keySet()) {

                Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>> threads = new HashMap<>();
                threadwise.put(phase, threads);

                for (int thread : rawJSON.get(phase).keySet()) {
                    List<SpeedGraphItemDTO.SpeedItemThreadwise> threadItems = new ArrayList<>();
                    threads.put(String.valueOf(thread), threadItems);

                    //speed items
                    for (SpeedItems.SpeedItem item : rawJSON.get(phase).get(thread)) {
                        SpeedGraphItemDTO.SpeedItemThreadwise measurement = new SpeedGraphItemDTO.SpeedItemThreadwise();
                        measurement.setBytesTotal(item.getBytes());
                        measurement.setTimeElapsed(item.getTime());
                        threadItems.add(measurement);
                    }
                }
            }

            dto.setSpeedCurveThreadwise(threadwise);
        }
    }

    private void setSpeeds(SpeedItems speedItems, OpenTestGraphDTO graphs) {
        if (speedItems != null) {
            long lastTime = -1;
            final List<SpeedItems.SpeedItem> uploadList = speedItems.getAccumulatedSpeedItemsUpload();
            final List<SpeedItems.SpeedItem> downloadList = speedItems.getAccumulatedSpeedItemsDownload();
            List<SpeedGraphItemDTO> downloadSpeeds = new ArrayList<>();
            List<SpeedGraphItemDTO> uploadSpeeds = new ArrayList<>();

            if (!RETURN_SMOOTHED_SPEED_CURVES) {
                processSpeedItems(lastTime, uploadList, uploadSpeeds);
                lastTime = -1;
                processSpeedItems(lastTime, downloadList, downloadSpeeds);
            } else {
                final List<? extends Smoothable> smoothedUploadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, uploadList, SMOOTHING_DATA_AMOUNT);
                final List<? extends Smoothable> smoothedDownloadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, downloadList, SMOOTHING_DATA_AMOUNT);
                lastTime = -1;
                processSmoothedSpeedItems(lastTime, uploadSpeeds, smoothedUploadList, 1000000);
                lastTime = -1;
                processSmoothedSpeedItems(lastTime, downloadSpeeds, smoothedDownloadList, 1e6);
            }
            graphs.setDownload(downloadSpeeds);
            graphs.setUpload(uploadSpeeds);
        }
    }

    private void processSmoothedSpeedItems(long lastTime, List<SpeedGraphItemDTO> speeds, List<? extends Smoothable> smoothedList, double i) {
        SpeedGraphItemDTO obj;
        for (Smoothable item : smoothedList) {
            obj = new SpeedGraphItemDTO();
            final long time = Math.round((double) item.getXValue() / i);
            if (time == lastTime)
                continue;
            obj.setTimeElapsed(time);
            obj.setBytesTotal(Math.round(Math.floor(item.getYValue())));
            speeds.add(obj);
        }
    }

    private void processSpeedItems(long lastTime, List<SpeedItems.SpeedItem> uploadList, List<SpeedGraphItemDTO> uploadSpeeds) {
        SpeedGraphItemDTO obj;
        for (SpeedItems.SpeedItem item : uploadList) {
            obj = new SpeedGraphItemDTO();
            final long time = Math.round((double) item.getTime() / 1e6);
            if (time == lastTime)
                continue;
            obj.setTimeElapsed(item.getTime());
            obj.setBytesTotal(item.getBytes());
            uploadSpeeds.add(obj);
            lastTime = time;
        }
    }

    private void setClassification(OpenTestDetailsDtoResponse dto) {
        if (dto.getDownloadKbit() != null)
            dto.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, dto.getDownloadKbit(), CAPABILITIES.getClassification().getCount()));
        if (dto.getUploadKbit() != null)
            dto.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, dto.getUploadKbit(), CAPABILITIES.getClassification().getCount()));
        if (dto.getPingMs() != null)
            dto.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(dto.getPingMs() * 1000000), CAPABILITIES.getClassification().getCount()));

        //classify signal accordingly
        if ((dto.getSignalStrength() != null || dto.getLteRsrp() != null)
                && dto.getNetworkType() != null) { // signal available
            if (dto.getLteRsrp() == null) { // use RSSI
                if (dto.getNetworkType().equals("WLAN")) { // RSSI for Wifi
                    dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, dto.getSignalStrength(), CAPABILITIES.getClassification().getCount()));
                } else { // RSSI for Mobile
                    dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, dto.getSignalStrength(), CAPABILITIES.getClassification().getCount()));
                }
            } else // RSRP for LTE
                dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_RSRP, dto.getLteRsrp(), CAPABILITIES.getClassification().getCount()));
        } else { // no signal available
            dto.setSignalClassification(null);
        }
    }

    private Integer parseVerboseLevel(String verbose) {
        return Optional.ofNullable(verbose)
                .map(x -> {
                    try {
                        return Integer.parseInt(x);
                    } catch (NumberFormatException ex) {
                        log.info("invalid non-numeric verbosity level");
                    }
                    return null;
                })
                .orElse(0);
    }

    private ResponseEntity<Object> getJsonResponseEntity(OpenTestSearchResponse openTestSearchResults, ResponseEntity.BodyBuilder representation) throws JsonProcessingException {
        ObjectMapper om = new ObjectMapper();
        om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        return representation
                .contentType(new MediaType("application", "json", StandardCharsets.UTF_8))
                .body(om.writer().writeValueAsString(openTestSearchResults));
    }

    private ResponseEntity<Object> getXlsxResponseEntity(OpenTestSearchResponse openTestSearchResults, ResponseEntity.BodyBuilder representation) throws IOException {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        XlsxMapper mapper = new XlsxMapper();
        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        CsvSchema schema = mapper.schemaFor(OpenTestDTO.class).withHeader();
        SequenceWriter sequenceWriter = mapper.writer(schema).writeValues(outputStream);
        sequenceWriter.writeAll(openTestSearchResults.getResults());
        sequenceWriter.flush();
        sequenceWriter.close();
        return representation
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + XLSX_FILENAME)
                .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                .body(outputStream.toByteArray());
    }

    private ResponseEntity<Object> getCsvResponseEntity(OpenTestSearchResponse openTestSearchResults, ResponseEntity.BodyBuilder representation) throws JsonProcessingException {
        CsvMapper cm = new CsvMapper();
        cm.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        cm.enable(CsvGenerator.Feature.STRICT_CHECK_FOR_QUOTING);
        CsvSchema schema = CsvSchema.builder().setLineSeparator("\r\n").setUseHeader(true)
                .addColumnsFrom(cm.schemaFor(OpenTestDTO.class)).build();
        return representation
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + CSV_FILENAME)
                .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                .body(cm.writer(schema).writeValueAsString(openTestSearchResults.getResults()));
    }

    private OpenTestSearchResponse getOpenTestSearchResponse(MultiValueMap<String, String> parameters) {
        final Set<String> additionalFields;
        final List<String> invalidElements = new ArrayList<>();
        final QueryParser qp = new QueryParser();
        qp.parseQuery(parameters);

        //calculate offset
        long offset = -1;
        if (Objects.nonNull(parameters.getFirst("cursor"))) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            offset = Long.parseLong(parameters.getFirst("cursor"));
        }

        //get maximal results-parameter
        long maxrows = DEFAULT_ROWS;
        if (Objects.nonNull(parameters.getFirst("max_results"))) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            maxrows = Long.parseLong(parameters.getFirst("max_results"));
        }

        //parse additional fields
        if (Objects.nonNull(parameters.getFirst("additional_info[]")) || Objects.nonNull(parameters.getFirst("additional_info"))) {
            List<String> param = Objects.nonNull(parameters.getFirst("additional_info[]")) ? parameters.get("additional_info[]") : parameters.get("additional_info");
            for (String field : param) {
                if (!allowedAdditionalFields.contains(field)) {
                    invalidElements.add("additional_info");
                }
            }
            additionalFields = new HashSet<>(param);
        } else {
            additionalFields = new HashSet<>();
        }

        //if there have been errors => inform the user
        if (invalidElements.size() > 0) {
            throw new InvalidFieldsException(invalidElements);
        }

        return openTestRepository.getOpenTestSearchResults(qp, offset, maxrows, additionalFields);
    }

    private class HistogramInfo {
        long max_download = Long.MIN_VALUE;
        long min_download = Long.MIN_VALUE;
        long max_upload = Long.MIN_VALUE;
        long min_upload = Long.MIN_VALUE;
        double max_ping = Long.MIN_VALUE;
        double min_ping = Long.MIN_VALUE;
    }
}
