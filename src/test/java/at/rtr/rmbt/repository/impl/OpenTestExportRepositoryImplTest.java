package at.rtr.rmbt.repository.impl;

import at.rtr.rmbt.TestConstants;
import at.rtr.rmbt.constant.Constants;
import at.rtr.rmbt.dto.OpenTestExportResult;
import at.rtr.rmbt.response.LocationGraphDTO;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(SpringExtension.class)
class OpenTestExportRepositoryImplTest {

    private static final String SQL_QUERY_HOUR = "SELECT" +
            " ('P' || t.open_uuid) open_uuid," +
            " ('O' || t.open_test_uuid) open_test_uuid," +
            " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
            " nt.group_name cat_technology," +
            " nt.name network_type," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_lat" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_lat*1111)/1111" +
            " ELSE null" +
            " END) latitude," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_long" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_long*741)/741 " +
            " ELSE null" +
            " END) longitude," +
            " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
            " 'rastered'" + //make raster transparent
            " ELSE tl.geo_provider" +
            " END) loc_src," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
            " THEN round(tl.geo_accuracy::float * 10)/10 " +
            " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN round(tl.geo_accuracy::float * 10)/10" +
            " ELSE null END) loc_accuracy, " +
            " tl.gkz_bev gkz," +
            " NULL zip_code," +
            " tl.country_location country_location," +
            " t.speed_download download_kbit," +
            " t.speed_upload upload_kbit," +
            " round(t.ping_median::float / 100000)/10 ping_ms," +
            " t.lte_rsrp," +
            " t.lte_rsrq," +
            " ts.name server_name," +
            " duration test_duration," +
            " num_threads," +
            " temperature," +
            " t.plattform platform," +
            " COALESCE(adm.fullname, t.model) model," +
            " client_software_version client_version," +
            " network_operator network_mcc_mnc," +
            " network_operator_name network_name," +
            " network_sim_operator sim_mcc_mnc," +
            " nat_type," +
            " public_ip_asn asn," +
            " client_public_ip_anonymized ip_anonym," +
            " (ndt.s2cspd*1000)::int ndt_download_kbit," +
            " (ndt.c2sspd*1000)::int ndt_upload_kbit," +
            " COALESCE(t.implausible, false) implausible," +
            " t.signal_strength," +
            " t.pinned pinned," +
            " tl.kg_nr_bev kg_nr," +
            " tl.gkz_sa gkz_sa," +
            " tl.land_cover, " +
            " t.cell_location_id cell_area_code," +
            " t.cell_area_code cell_location_id," +
            " t.channel_number channel_number," +
            " t.radio_band radio_band" +
            " , tl.settlement_type settlement_type" +
            " , tl.link_id link_id" +
            " , tl.link_name link_name" +
            " , tl.link_distance link_distance" +
            " , tl.edge_id edge_id" +
            " , tl.frc link_frc" +
            " , tl.dtm_level dtm_level" +
            " , tl.atraster100 atraster100" +
            " , tl.atraster250 atraster250" +
            " FROM test t" +
            " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
            " LEFT JOIN device_map adm ON adm.codename=t.model" +
            " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
            " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
            " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
            " WHERE " +
            " t.deleted = false " +
            "AND time > now() - (?||' hours')::INTERVAL " +
            "AND status = 'FINISHED' " +
            "ORDER BY t.uid";

    private static final String SQL_QUERY_MONTH_AND_YEAR = "SELECT" +
            " ('P' || t.open_uuid) open_uuid," +
            " ('O' || t.open_test_uuid) open_test_uuid," +
            " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
            " nt.group_name cat_technology," +
            " nt.name network_type," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_lat" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_lat*1111)/1111" +
            " ELSE null" +
            " END) latitude," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_long" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_long*741)/741 " +
            " ELSE null" +
            " END) longitude," +
            " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
            " 'rastered'" + //make raster transparent
            " ELSE tl.geo_provider" +
            " END) loc_src," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
            " THEN round(tl.geo_accuracy::float * 10)/10 " +
            " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN round(tl.geo_accuracy::float * 10)/10" +
            " ELSE null END) loc_accuracy, " +
            " tl.gkz_bev gkz," +
            " NULL zip_code," +
            " tl.country_location country_location," +
            " t.speed_download download_kbit," +
            " t.speed_upload upload_kbit," +
            " round(t.ping_median::float / 100000)/10 ping_ms," +
            " t.lte_rsrp," +
            " t.lte_rsrq," +
            " ts.name server_name," +
            " duration test_duration," +
            " num_threads," +
            " temperature," +
            " t.plattform platform," +
            " COALESCE(adm.fullname, t.model) model," +
            " client_software_version client_version," +
            " network_operator network_mcc_mnc," +
            " network_operator_name network_name," +
            " network_sim_operator sim_mcc_mnc," +
            " nat_type," +
            " public_ip_asn asn," +
            " client_public_ip_anonymized ip_anonym," +
            " (ndt.s2cspd*1000)::int ndt_download_kbit," +
            " (ndt.c2sspd*1000)::int ndt_upload_kbit," +
            " COALESCE(t.implausible, false) implausible," +
            " t.signal_strength," +
            " t.pinned pinned," +
            " tl.kg_nr_bev kg_nr," +
            " tl.gkz_sa gkz_sa," +
            " tl.land_cover, " +
            " t.cell_location_id cell_area_code," +
            " t.cell_area_code cell_location_id," +
            " t.channel_number channel_number," +
            " t.radio_band radio_band" +
            " , tl.settlement_type settlement_type" +
            " , tl.link_id link_id" +
            " , tl.link_name link_name" +
            " , tl.link_distance link_distance" +
            " , tl.edge_id edge_id" +
            " , tl.frc link_frc" +
            " , tl.dtm_level dtm_level" +
            " , tl.atraster100 atraster100" +
            " , tl.atraster250 atraster250" +
            " FROM test t" +
            " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
            " LEFT JOIN device_map adm ON adm.codename=t.model" +
            " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
            " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
            " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
            " WHERE " +
            " t.deleted = false " +
            "AND (EXTRACT (month FROM t.time AT TIME ZONE 'UTC') = ?) " +
            "AND (EXTRACT (year FROM t.time AT TIME ZONE 'UTC') = ?) " +
            "AND status = 'FINISHED' " +
            "ORDER BY t.uid";

    private final static String SQL_QUERY_LAST_31_DAYS = "SELECT" +
            " ('P' || t.open_uuid) open_uuid," +
            " ('O' || t.open_test_uuid) open_test_uuid," +
            " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
            " nt.group_name cat_technology," +
            " nt.name network_type," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_lat" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_lat*1111)/1111" +
            " ELSE null" +
            " END) latitude," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
            " tl.geo_long" +
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN" +
            " ROUND(tl.geo_long*741)/741 " +
            " ELSE null" +
            " END) longitude," +
            " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
            " 'rastered'" + //make raster transparent
            " ELSE tl.geo_provider" +
            " END) loc_src," +
            " (CASE WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
            " THEN round(tl.geo_accuracy::float * 10)/10 " +
            " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
            " WHEN (tl.geo_accuracy < " + Constants.RMBT_GEO_ACCURACY_DETAIL_LIMIT + ") THEN round(tl.geo_accuracy::float * 10)/10" +
            " ELSE null END) loc_accuracy, " +
            " tl.gkz_bev gkz," +
            " NULL zip_code," +
            " tl.country_location country_location," +
            " t.speed_download download_kbit," +
            " t.speed_upload upload_kbit," +
            " round(t.ping_median::float / 100000)/10 ping_ms," +
            " t.lte_rsrp," +
            " t.lte_rsrq," +
            " ts.name server_name," +
            " duration test_duration," +
            " num_threads," +
            " temperature," +
            " t.plattform platform," +
            " COALESCE(adm.fullname, t.model) model," +
            " client_software_version client_version," +
            " network_operator network_mcc_mnc," +
            " network_operator_name network_name," +
            " network_sim_operator sim_mcc_mnc," +
            " nat_type," +
            " public_ip_asn asn," +
            " client_public_ip_anonymized ip_anonym," +
            " (ndt.s2cspd*1000)::int ndt_download_kbit," +
            " (ndt.c2sspd*1000)::int ndt_upload_kbit," +
            " COALESCE(t.implausible, false) implausible," +
            " t.signal_strength," +
            " t.pinned pinned," +
            " tl.kg_nr_bev kg_nr," +
            " tl.gkz_sa gkz_sa," +
            " tl.land_cover, " +
            " t.cell_location_id cell_area_code," +
            " t.cell_area_code cell_location_id," +
            " t.channel_number channel_number," +
            " t.radio_band radio_band" +
            " , tl.settlement_type settlement_type" +
            " , tl.link_id link_id" +
            " , tl.link_name link_name" +
            " , tl.link_distance link_distance" +
            " , tl.edge_id edge_id" +
            " , tl.frc link_frc" +
            " , tl.dtm_level dtm_level" +
            " , tl.atraster100 atraster100" +
            " , tl.atraster250 atraster250" +
            " FROM test t" +
            " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
            " LEFT JOIN device_map adm ON adm.codename=t.model" +
            " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
            " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
            " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
            " WHERE " +
            " t.deleted = false " +
            "AND time > current_date - interval '31 days' " +
            "AND status = 'FINISHED' " +
            "ORDER BY t.uid";
    @Mock
    private JdbcTemplate jdbcTemplate;
    @InjectMocks
    private OpenTestExportRepositoryImpl openTestExportRepository;

    @Captor
    private ArgumentCaptor<PreparedStatementCreator> preparedStatementCreator;
    @Captor
    private ArgumentCaptor<PreparedStatementSetter> preparedStatementSetter;
    @Captor
    private ArgumentCaptor<ResultSetExtractor<List<OpenTestExportResult>>> resultSetExtractor;

    @Mock
    private Connection connection;
    @Mock
    private PreparedStatement preparedStatement;
    @Mock
    private ResultSet resultSet;

    @Test
    void getOpenTestExportHour_correctInvocation_OpenTestExportResults() throws SQLException {
        openTestExportRepository.getOpenTestExportHour(TestConstants.DEFAULT_HOUR);

        verify(jdbcTemplate).query(preparedStatementCreator.capture(), preparedStatementSetter.capture(), resultSetExtractor.capture());

        preparedStatementCreator.getValue().createPreparedStatement(connection);
        verify(connection).prepareStatement(SQL_QUERY_HOUR);

        preparedStatementSetter.getValue().setValues(preparedStatement);
        verify(preparedStatement).setInt(1, TestConstants.DEFAULT_HOUR);

        when(resultSet.next()).thenReturn(true, false);
        mockResultSet();
        var extractedResult = resultSetExtractor.getValue().extractData(resultSet);
        assertEquals(expectedOpenTestExportResults(), extractedResult);
    }

    @Test
    void getOpenTestExportMonth_correctInvocation_OpenTestExportResults() throws SQLException {
        openTestExportRepository.getOpenTestExportMonth(TestConstants.DEFAULT_YEAR, TestConstants.DEFAULT_MONTH);

        verify(jdbcTemplate).query(preparedStatementCreator.capture(), preparedStatementSetter.capture(), resultSetExtractor.capture());

        preparedStatementCreator.getValue().createPreparedStatement(connection);
        verify(connection).prepareStatement(SQL_QUERY_MONTH_AND_YEAR);

        preparedStatementSetter.getValue().setValues(preparedStatement);
        verify(preparedStatement).setInt(1, TestConstants.DEFAULT_MONTH);
        verify(preparedStatement).setInt(2, TestConstants.DEFAULT_YEAR);

        when(resultSet.next()).thenReturn(true, false);
        mockResultSet();
        var extractedResult = resultSetExtractor.getValue().extractData(resultSet);
        assertEquals(expectedOpenTestExportResults(), extractedResult);
    }

    @Test
    void getOpenTestExportLast31Days_correctInvocation_OpenTestExportResults() throws SQLException {
        openTestExportRepository.getOpenTestExportLast31Days();

        verify(jdbcTemplate).query(preparedStatementCreator.capture(), resultSetExtractor.capture());

        preparedStatementCreator.getValue().createPreparedStatement(connection);
        verify(connection).prepareStatement(SQL_QUERY_LAST_31_DAYS);

        when(resultSet.next()).thenReturn(true, false);
        mockResultSet();
        var extractedResult = resultSetExtractor.getValue().extractData(resultSet);
        assertEquals(expectedOpenTestExportResults(), extractedResult);
    }

    private void mockResultSet() throws SQLException {
        when(resultSet.getString("open_uuid")).thenReturn(TestConstants.DEFAULT_OPEN_UUID);
        when(resultSet.getString("open_test_uuid")).thenReturn(TestConstants.DEFAULT_OPEN_TEST_UUID_STRING);
        when(resultSet.getString("time")).thenReturn(TestConstants.DEFAULT_TIME_STRING);
        when(resultSet.getString("cat_technology")).thenReturn(TestConstants.DEFAULT_CAT_TECHNOLOGY);
        when(resultSet.getString("network_type")).thenReturn(TestConstants.DEFAULT_NETWORK_TYPE);
        when(resultSet.getObject("latitude", Double.class)).thenReturn(TestConstants.DEFAULT_LATITUDE);
        when(resultSet.getObject("longitude", Double.class)).thenReturn(TestConstants.DEFAULT_LONGITUDE);
        when(resultSet.getString("loc_src")).thenReturn(TestConstants.DEFAULT_LOC_SRC);
        when(resultSet.getObject("loc_accuracy", Double.class)).thenReturn(TestConstants.DEFAULT_LOC_ACCURACY);
        when(resultSet.getObject("gkz", Integer.class)).thenReturn(TestConstants.DEFAULT_GKZ);
        when(resultSet.getString("zip_code")).thenReturn(TestConstants.DEFAULT_ZIP_CODE);
        when(resultSet.getString("country_location")).thenReturn(TestConstants.DEFAULT_COUNTRY_LOCATION);
        when(resultSet.getObject("download_kbit", Integer.class)).thenReturn(TestConstants.DEFAULT_DOWNLOAD_KBIT);
        when(resultSet.getObject("upload_kbit", Integer.class)).thenReturn(TestConstants.DEFAULT_UPLOAD_KBIT);
        when(resultSet.getObject("ping_ms", Double.class)).thenReturn(TestConstants.DEFAULT_PING_MS);
        when(resultSet.getObject("lte_rsrp", Integer.class)).thenReturn(TestConstants.DEFAULT_LTE_RSRP);
        when(resultSet.getObject("lte_rsrq", Integer.class)).thenReturn(TestConstants.DEFAULT_LTE_RSRQ);
        when(resultSet.getString("server_name")).thenReturn(TestConstants.DEFAULT_SERVER_NAME);
        when(resultSet.getObject("test_duration", Integer.class)).thenReturn(TestConstants.DEFAULT_TEST_DURATION);
        when(resultSet.getObject("num_threads", Integer.class)).thenReturn(TestConstants.DEFAULT_NUM_THREADS);
        when(resultSet.getString("platform")).thenReturn(TestConstants.DEFAULT_PLATFORM);
        when(resultSet.getString("model")).thenReturn(TestConstants.DEFAULT_MODEL);
        when(resultSet.getString("client_version")).thenReturn(TestConstants.DEFAULT_CLIENT_VERSION);
        when(resultSet.getString("network_mcc_mnc")).thenReturn(TestConstants.DEFAULT_NETWORK_MCC_MNC);
        when(resultSet.getString("network_name")).thenReturn(TestConstants.DEFAULT_NETWORK_NAME);
        when(resultSet.getString("sim_mcc_mnc")).thenReturn(TestConstants.DEFAULT_SIM_MCC_MNC);
        when(resultSet.getString("nat_type")).thenReturn(TestConstants.DEFAULT_NAT_TYPE);
        when(resultSet.getObject("asn", Long.class)).thenReturn(TestConstants.DEFAULT_ASN);
        when(resultSet.getString("ip_anonym")).thenReturn(TestConstants.DEFAULT_IP_ANONYM);
        when(resultSet.getObject("ndt_download_kbit", Integer.class)).thenReturn(TestConstants.DEFAULT_NDT_DOWNLOAD_KBIT);
        when(resultSet.getObject("ndt_upload_kbit", Integer.class)).thenReturn(TestConstants.DEFAULT_NDT_UPLOAD_KBIT);
        when(resultSet.getObject("implausible", Boolean.class)).thenReturn(TestConstants.DEFAULT_IMPLAUSIBLE);
        when(resultSet.getObject("signal_strength", Integer.class)).thenReturn(TestConstants.DEFAULT_SIGNAL_STRENGTH);
        when(resultSet.getObject("pinned", Boolean.class)).thenReturn(TestConstants.DEFAULT_PINNED);
        when(resultSet.getObject("kg_nr", Integer.class)).thenReturn(TestConstants.DEFAULT_KG_NR);
        when(resultSet.getObject("gkz_sa", Integer.class)).thenReturn(TestConstants.DEFAULT_GKZ_SA);
        when(resultSet.getObject("land_cover", Integer.class)).thenReturn(TestConstants.DEFAULT_LAND_COVER);
        when(resultSet.getObject("cell_area_code", Long.class)).thenReturn(TestConstants.DEFAULT_CELL_AREA_CODE);
        when(resultSet.getObject("cell_location_id", Long.class)).thenReturn(TestConstants.DEFAULT_CELL_LOCATION_ID);
        when(resultSet.getObject("channel_number", Integer.class)).thenReturn(TestConstants.DEFAULT_CHANNEL_NUMBER);
        when(resultSet.getObject("radio_band", Integer.class)).thenReturn(TestConstants.DEFAULT_RADIO_BAND);
        when(resultSet.getObject("settlement_type", Integer.class)).thenReturn(TestConstants.DEFAULT_SETTLEMENT_TYPE);
        when(resultSet.getObject("link_id", Integer.class)).thenReturn(TestConstants.DEFAULT_LINK_ID);
        when(resultSet.getString("link_name")).thenReturn(TestConstants.DEFAULT_LINK_NAME);
        when(resultSet.getObject("link_distance", Integer.class)).thenReturn(TestConstants.DEFAULT_LINK_DISTANCE);
        when(resultSet.getString("edge_id")).thenReturn(TestConstants.DEFAULT_EDGE_ID);
        when(resultSet.getObject("link_frc", Integer.class)).thenReturn(TestConstants.DEFAULT_LINK_FRC);
        when(resultSet.getObject("dtm_level", Integer.class)).thenReturn(TestConstants.DEFAULT_DTM_LEVEL);
    }

    private List<OpenTestExportResult> expectedOpenTestExportResults() {
        OpenTestExportResult openTestExportResult = OpenTestExportResult.builder()
                .openUuid(TestConstants.DEFAULT_OPEN_UUID)
                .openTestUuid(TestConstants.DEFAULT_OPEN_TEST_UUID_STRING)
                .time(TestConstants.DEFAULT_TIME_STRING)
                .catTechnology(TestConstants.DEFAULT_CAT_TECHNOLOGY)
                .networkType(TestConstants.DEFAULT_NETWORK_TYPE)
                .latitude(TestConstants.DEFAULT_LATITUDE)
                .longitude(TestConstants.DEFAULT_LONGITUDE)
                .locSrc(TestConstants.DEFAULT_LOC_SRC)
                .locAccuracy(TestConstants.DEFAULT_LOC_ACCURACY)
                .gkz(TestConstants.DEFAULT_GKZ)
                .zipCode(TestConstants.DEFAULT_ZIP_CODE)
                .countryLocation(TestConstants.DEFAULT_COUNTRY_LOCATION)
                .downloadKbit(TestConstants.DEFAULT_DOWNLOAD_KBIT)
                .uploadKbit(TestConstants.DEFAULT_UPLOAD_KBIT)
                .pingMs(TestConstants.DEFAULT_PING_MS)
                .lteRsrp(TestConstants.DEFAULT_LTE_RSRP)
                .lteRsrq(TestConstants.DEFAULT_LTE_RSRQ)
                .serverName(TestConstants.DEFAULT_SERVER_NAME)
                .testDuration(TestConstants.DEFAULT_TEST_DURATION)
                .numThreads(TestConstants.DEFAULT_NUM_THREADS)
                .platform(TestConstants.DEFAULT_PLATFORM)
                .model(TestConstants.DEFAULT_MODEL)
                .clientVersion(TestConstants.DEFAULT_CLIENT_VERSION)
                .networkMccMnc(TestConstants.DEFAULT_NETWORK_MCC_MNC)
                .networkName(TestConstants.DEFAULT_NETWORK_NAME)
                .simMccMnc(TestConstants.DEFAULT_SIM_MCC_MNC)
                .natType(TestConstants.DEFAULT_NAT_TYPE)
                .asn(TestConstants.DEFAULT_ASN)
                .ipAnonym(TestConstants.DEFAULT_IP_ANONYM)
                .ndtDownloadKbit(TestConstants.DEFAULT_NDT_DOWNLOAD_KBIT)
                .ndtUploadKbit(TestConstants.DEFAULT_NDT_UPLOAD_KBIT)
                .implausible(TestConstants.DEFAULT_IMPLAUSIBLE)
                .signalStrength(TestConstants.DEFAULT_SIGNAL_STRENGTH)
                .pinned(TestConstants.DEFAULT_PINNED)
                .kgNr(TestConstants.DEFAULT_KG_NR)
                .gkzSa(TestConstants.DEFAULT_GKZ_SA)
                .landCover(TestConstants.DEFAULT_LAND_COVER)
                .cellAreaCode(TestConstants.DEFAULT_CELL_AREA_CODE)
                .cellLocationId(TestConstants.DEFAULT_CELL_LOCATION_ID)
                .channelNumber(TestConstants.DEFAULT_CHANNEL_NUMBER)
                .radioBand(TestConstants.DEFAULT_RADIO_BAND)
                .settlementType(TestConstants.DEFAULT_SETTLEMENT_TYPE)
                .linkId(TestConstants.DEFAULT_LINK_ID)
                .linkName(TestConstants.DEFAULT_LINK_NAME)
                .linkDistance(TestConstants.DEFAULT_LINK_DISTANCE)
                .edgeId(TestConstants.DEFAULT_EDGE_ID)
                .linkFrc(TestConstants.DEFAULT_LINK_FRC)
                .dtmLevel(TestConstants.DEFAULT_DTM_LEVEL)
                .build();
        return List.of(openTestExportResult);
    }
}